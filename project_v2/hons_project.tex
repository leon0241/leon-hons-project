\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


\usepackage[final, nopatch=footnote]{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

\usepackage{preamble}
% \overfullrule=20mm


\begin{document}
\begin{preliminary}

\title{Honours Project}

\author{Leon Lee}
\course{Computer Science and Mathematics}
\project{4th Year Project Report}
\date{\today}

\abstract{
This skeleton demonstrates how to use the \texttt{infthesis} style for
undergraduate dissertations in the School of Informatics. It also emphasises the
page limit, and that you must not deviate from the required style.
The file \texttt{skeleton.tex} generates this document and should be used as a
starting point for your thesis. Replace this abstract text with a concise
summary of your report.
}

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
Any acknowledgements go here.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

\chapter{Background}

\section{Process Algebra}
With the growing complexities of software and systems of the world, it is key to have methods of modelling more complex systems to get a better understanding of the underlying behaviour behind processes. Efforts have been made in sequential programming as early as the 1930s with Turing Machines, and the $\lambda$-calculus. Systems in real life are rarely sequential however, and usually involve multiple processes acting simultaneously, sometimes even synchronising to interact with each other to perform tasks. These tasks that involve modelling multiple processes at once are referred to as a \textit{Concurrent System}. It is clear to see that brute forcing solutions to these problems are significantly harder than a sequential system - the processing time will grow exponentially as the number of processes increase, and modelling a system like a colony of ants is near impossible. Therefore, we will need some way to formalise these Concurrent Systems.

Concurrency has been studied in many different ways, though with the earliest  the 1960s with some notable models being Petri nets, or the Actor Model. Process Algebras are one such method of modelling a Concurrent System, where the process is modelled in such a way that it is akin to the Universal Algebras of mathematics - in which operations are defined in an axiomatic approach to create a structurally sound way of defining concurrent systems. \citep{baetenBriefHistoryProcess2005} It is easily possible to model simple systems as a flow chart or diagram as you will be able to see throughout this paper, but a formal approach like process algebras will make way for modelling more complex systems, and lays the groundwork to provide a solid foundation to prove and base claims for such systems.

A simple example in action is a process algebra where we only consider the alternative composition operator $+$, where applied to a process $a + b$ means ``Choose $a$, or choose $b$''. Process algebras can typically be modelled in a \textit{Process Graph}, which are diagrams that employ ``states'', and ``actions'' to show the traces, or paths, that a process can take. In this case, the process $a + b$ can be modelled in the following way:

% https://q.uiver.app/#q=WzAsNixbMSwxLCJcXGNpcmMiXSxbMCwyLCJcXGNpcmMiXSxbMiwyLCJcXGNpcmMiXSxbMiw1XSxbMSw1LCJcXGJ1bGxldCJdLFsxLDBdLFswLDEsImEiLDJdLFswLDIsImIiXSxbMyw0XSxbNSwwXV0=
\[\begin{tikzcd}[cramped,column sep=small]
	& {} \\
	& \circ \\
	\circ && \circ \\
	\arrow[from=1-2, to=2-2]
	\arrow["a"', from=2-2, to=3-1]
	\arrow["b", from=2-2, to=3-3]
\end{tikzcd}\]

Where the graph begins at the top into the first node, and then can either progress to the left node via the action $a$, or the right node via the action $b$. $a$ and $b$ are the actions, e.g. ``eat'' and ``drink'', while the nodes are the states, e.g. ``apple'' and ``water''

The axioms of the $+$ operator of BPA are as follows:
\begin{itemize}
    \item \textbf{Commutativity}: $a + b$
    \item \textbf{Associativity}: $(a + b) + c = a + (b + c)$
    \item \textbf{Idempotency}: $a + a = a$
\end{itemize}
Comparable to the operation axioms of a Group or Ring in Mathematics, every other operation in a process algebra is constructed similarly. In practice, most process algebras will have some form of alternative composition, but this is a very simplified example and the developed process algebras that exist are designed to handle a lot more complex situations such as unobservable actions, commonly referred to as $\tau$-actions, recursion, which lets a process repeat itself or other processes, and deadlock, which is a state where no desirable outcomes can be reached.

There are many process algebras that exist, the most famous and seminal being $\csp$ \citep{brookesTheoryCommunicatingSequential1984}, CCS \citep{milnerCalculusCommunicatingSystems1980}, and ACP \citep{bergstraProcessAlgebraSynchronous1984}, \citep{bergstraACPtUniversalAxiom1989}, with some other popular calculi being the $\pi$-calculus and its various extensions  \citep{MILNER19921}, \citep{parrowFusionCalculusExpressiveness1998}, \citep{abadiCalculusCryptographicProtocols1999} which have been used to varying degrees in fields like Biology, Business, and Cryptography, or the Ambient Calculus \citep{cardelliMobileAmbients1998} which has been used to model mobile devices.

\section{Encodings of Process Algebra}

With the growing number of process algebras, one might begin to ask if there is a way of comparing different process algebra to each other to find the single best one, as a parallel to Turing Machines and the Church-Turing thesis. However, the wide range of applications that different process algebra are used for makes that rather impractical, and the goal of unifying all process algebra into a single theory seems further and further away as more process algebras for even more specified tasks get created.

A more reasonable approach is to compare different process algebras and their expressiveness, two main relevant methods being \textit{absolute} and \textit{relative} expressiveness.\citep{parrowExpressivenessProcessAlgebras2008} Absolute expressiveness is the idea of comparing a specific process algebra to a question and seeing if it can solve the problem - e.g. if a process algebra is Turing Complete. However, this merely biparts different algebra - the process algebra that are able to solve a specified problem, and the ones who aren't \citep{gorlaUnifiedApproachEncodability2010}. Therefore, the question of relative expressiveness - i.e. how one language compares to another is a lot more useful in terms of categorising different process algebras by expressiveness.

A well studied way of comparing expressiveness is through an ``encoding'', and whether an algebra can be translated from one to another, but not vice versa \citep{petersComparingProcessCalculi2019}. The general notion of an encoding is not defined by clear boundaries, and the criterion for a valid encoding may vary from language to language, but work has been made to try and generalise the notion of a ``valid'' encoding \citep{gorlaUnifiedApproachEncodability2010}, \citep{DBLP:conf/fossacs/Glabbeek18}.

\section{\texorpdfstring{$\csp$}{CSP}}
$\csp$ (Communicating Sequential Processes) \citep{brookesTheoryCommunicatingSequential1984} is a Process Algebra developed by Tony Hoare based on the idea of message passing via communications. It was developed in the 1980s and was one of the first of its kind, alongside CCS by Milner. $\csp$ uses the idea of action prefixing which is where operators are of the syntax $a \to P$, where $a$ is an event and $P$ is a process. 

As taken from \citet{vanglabbeekBranchingTimeModel2017}, the syntax of $\csp$ can be expressed as follows
\begin{align*}
   P, Q ::= &\mathrm{STOP} \mid \div \mid a\to P \mid P \intchoice Q \mid P \extchoice Q \mid P \sliding Q \mid \\
	&P \pcomp Q \mid P \conceal A \mid f(P) \mid P \interrupt Q \mid P \interrupt Q \mid p \mid \mu p.P
\end{align*}
where the operators are: \textit{inaction}, \textit{divergence}, \textit{action prefixing}, \textit{internal choice}, \textit{external choice}, \textit{sliding choice}, \textit{parallel composition}, \textit{concealment}, \textit{renaming}, \textit{interrupt}, and \textit{throw}.


\section{ACP}
ACP (Algebra of Communicating Processes) is a Process Algebra developed by Jan Bergstra and Jan Willem Klop \citep{bergstraProcessAlgebraSynchronous1984}. Compared to $\csp$, ACP is built up with an axiomatic approach in mind which does away with the idea of action prefixing and instead can allow for unguarded operations. ACP$_{\tau}$ \citep{bergstraACPtUniversalAxiom1989} is an extension of ACP that includes an extra action $\tau$ which is used to represent actions that are unobservable, or changeable, from a human perspective.

The grammar of ACP$_{\tau}$ as taken from \citep{bergstraACPtUniversalAxiom1989} is defined as such:
\begin{align*}
   P, Q ::= a \mid \delta \mid E + F \mid E . F \mid E | | F \mid E \underline{| | \,} F \mid E | F \mid \partial_{H}(E) \mid \tau_{I}
\end{align*}
where the operators are: \textit{action}, \textit{deadlock}, \textit{alternative composition}, \textit{sequential composition}, \textit{merge}, \textit{left merge}, \textit{communication merge}, \textit{encapsulation}, \textit{abstraction}


{\huge [WIP]}

\chapter{A formal definition of \texorpdfstring{$\csp$}{CSP} and \texorpdfstring{$\acptf$}{ACP}}

\section{Languages}\label{ssec:language}

From [EXPRESSIVENESS], we represent a language $\mathscr{L}$ as a pair $(\mathbb{T}, \oper)$, where $\mathbb{T}$ is a set of valid expressions in $\mathscr{L}$, and $\oper$ is a mapping $\oper c: \mathbb{T} \to \mathscr{D}$ from $\mathbb{T}$ to a set of meanings $\mathscr{D}$. We also define $A \subseteq \mathbb{T}$, where $A$ is the set of actions

\section{\texorpdfstring{$\csp$}{CSP}}\label{ssec:CSP}
As stated above, our proposed grammar of $\csp$ consists of the operations:

\begin{align*}
   P, Q ::= &\mathrm{STOP} \mid \mathrm{div} \mid a\to P \mid P \sqcap Q \mid P \extchoice Q \mid P \triangleleft Q \mid \\
	&P | |_{A} Q \mid P \backslash A \mid f(P) \mid P \triangle Q \mid P \theta_{A} Q \mid 
\end{align*}
%\mu p.P
where the operators are: \textit{inaction}, \textit{divergence}, \textit{action prefixing}, \textit{internal choice}, \textit{external choice}, \textit{sliding choice}, \textit{parallel composition}, \textit{concealment}, \textit{renaming}, \textit{interrupt}, and \textit{throw}.

These can also be represented in the following GSOS table

\begin{table}[htb]
\begin{center}
\framebox{$\begin{array}{ccccc}
\div\prightarrow{\tau}\div &
(a\rightarrow P) \prightarrow{a} P &
P \intchoice Q \prightarrow{\tau} P &
P \intchoice Q \prightarrow{\tau} Q \\[2ex]
\displaystyle\frac{P\prightarrow{a} P'}{P\extchoice Q \prightarrow{a} P'} &
\displaystyle\frac{P\prightarrow{\tau} P'}{P\extchoice Q \prightarrow{\tau} P'\extchoice Q} &
\displaystyle\frac{Q\prightarrow{a} Q'}{P\extchoice Q \prightarrow{a} Q'} &
\displaystyle\frac{Q\prightarrow{\tau} Q'}{P\extchoice Q \prightarrow{\tau} P\extchoice Q'} \\[4ex]
\displaystyle\frac{P\prightarrow{a} P'}{P\sliding Q \prightarrow{a} P'} &
\displaystyle\frac{P\prightarrow{\tau} P'}{P\sliding Q \prightarrow{\tau} P'\sliding Q} &
P \sliding Q \prightarrow{\tau} Q &
\displaystyle\frac{P \prightarrow{\alpha} P'}{f(P) \prightarrow{f(\alpha)} f(P')} \\[4ex]
\displaystyle\frac{P\prightarrow{\alpha} P'~~{\scriptstyle(\alpha\notin A)}}{P\|_AQ \prightarrow{\alpha} P'\|_AQ} &
\multicolumn{2}{c}{
\displaystyle\frac{P\prightarrow{a} P'~~Q\prightarrow{a} Q'~~{\scriptstyle(a\in A)}}{P\|_AQ \prightarrow{a} P'\|_AQ'}} &
\displaystyle\frac{Q\prightarrow{\alpha} Q'~~{\scriptstyle(\alpha\notin A)}}{P\|_AQ \prightarrow{\alpha} P\|_AQ'} \\[4ex]
\displaystyle\frac{P \prightarrow{\alpha} P'~~{\scriptstyle(\alpha\notin A)}}{P\conceal A \prightarrow{\alpha} P'\conceal A} &
\displaystyle\frac{P \prightarrow{a} P'~~{\scriptstyle(a\in A)}}{P\conceal A \prightarrow{\tau} P'\conceal A} &
\displaystyle\frac{P\prightarrow{\alpha} P'~~{\scriptstyle(\alpha\notin A)}}{P\interrupt Q \prightarrow{a} P'\interrupt Q} &
\displaystyle\frac{P\prightarrow{a} P'~~{\scriptstyle(a\in A)}}{P\interrupt Q \prightarrow{a} Q}\\[4ex]
\displaystyle\frac{P\prightarrow{\alpha} P'}{P\triangle Q \prightarrow{\alpha} P'\triangle Q} &
\displaystyle\frac{Q\prightarrow{\tau} Q'}{P\triangle Q \prightarrow{\tau} P'\triangle Q'} &
\displaystyle\frac{Q\prightarrow{a} Q'}{P\triangle Q \prightarrow{a} Q'} &
\multicolumn{2}{c}{\mu p.P \xrightarrow{\mathmakebox[10pt]{\tau}} P[\mu p.P/p]}
\end{array}$}
\end{center}
\caption{Structural operational semantics of CSP}
\label{tab:CSP}
\end{table}


\section{\texorpdfstring{$\acptf$}{ACP-tf}}


\begin{table}[htb]
\begin{center}
\framebox{$\begin{array}{ccccc}
(a. P) \prightarrow{\alpha} P &
P + Q \prightarrow{\alpha} P &
P + Q \prightarrow{\alpha} Q \\[2ex]
% \displaystyle\frac{P \prightarrow{\alpha} P'}{f(P) \prightarrow{f(\alpha)} f(P')} \\[4ex]
\displaystyle\frac{P\prightarrow{\alpha} P'}{P \merge Q \prightarrow{\alpha} P' \merge Q} &
\displaystyle\frac{P\prightarrow{a} P'~~Q\prightarrow{b} Q'~~ a \mid b = c}{P \merge Q \prightarrow{a} P' \merge Q'} &
\displaystyle\frac{Q\prightarrow{\alpha} Q'}{P \merge Q \prightarrow{\alpha} P \merge Q'} \\[4ex]

\displaystyle\frac{P \prightarrow{\alpha} P'~~{\scriptstyle(\alpha\notin A)}}{\restrict(P) \prightarrow{\alpha} \restrict(P')} &

\displaystyle\frac{\langle \mathcal{S}_{X} \mid \mathcal{S} \rangle \prightarrow{a} P'}{\langle X \mid \mathcal{S} \rangle \prightarrow{a} P'} &


\end{array}$}
\end{center}
\caption{Structural operational semantics of ACP}
\label{table:ACP}
\end{table}

\begin{align*}
   P, Q ::= a \mid \delta \mid E + F \mid E . F \mid E \merge F \mid E \leftmerge F \mid E | F \mid \restrict(E) \mid \tau_{I}
\end{align*}
where the operators are: \textit{action}, \textit{deadlock}, \textit{alternative composition}, \textit{sequential composition}, \textit{merge}, \textit{left merge}, \textit{communication merge}, \textit{encapsulation}, \textit{abstraction}

A proposed extension of ACP adds a Functional Renaming operator, as shown in [ON THE EXPRESSIVENESS OF ACP]. From this point forth, we will be using this extension, written as $ACP^{\tau}_{F}$. 


\section{Expressiveness}
Somethin something we are trying to gain an expressiveness result by translating $\csp$ to $\acpt$. A result of a valid translation would therefore show that $\csp$ is \textit{at least as expressive} as $\acpt$.

\chapter{A Translation of \texorpdfstring{$\csp$}{CSP} to \texorpdfstring{$\acptf$}{ACP}}


\section{Direct Translations}
Some of the basic operations of $\csp$ have an identical equivalence in ACP, with the only difference being the syntax. These can be easily translated in the following table.
\begin{align*}
   \trans{STOP} &= \delta \\
   \trans{a \to P} &= a.\trans{P} \\
   \trans{P \backslash A} &= \partial_{A}{\trans{P}} \\
   % \trans{\mu p.P} &= \langle X \mid X = \tau.X \rangle
\end{align*}

\section{Trivial Translations}
\begin{itemize}
   \item \textbf{Divergence} is the process that diverges via infinite internal actions. It is defined by the following rule:
      \[\mathrm{div} \prightarrow{\tau} \mathrm{div}\]
      and then can be directly translated via recursion in ACP in the following rule:
      \[\trans{\mathrm{div}} = \langle X \mid X = \tau.X \rangle\] 
   \item \textbf{Renaming} is an operation that renames actions in processes according to a function. There is no equivalent function in plain $\mathrm{ACP}_{\tau}$, with the closest operation being $\tau_{I}(P)$ which abstracts actions in $I$ to internal actions. This is possible in $\acptf$, and in fact our translation is trivially
      \[\trans{f(P)} = f(\trans{P})\]

   \item \textbf{Internal Choice} is an operation that emulates a choice of actions that cannot be decided by the user. $\csp$ in particular differs from ACP in that external choice and internal choice are separate operations, while in ACP, the alternative choice operator $+$ handles choice, albeit slightly differently. With the internal choice operator $\tau$, a translation for $\csp$ Internal choice into ACP is easily written as
      \[\trans{P \sqcap Q} = \tau.\trans{P} + \tau.\trans{Q}\]
\end{itemize}

The above translations are all valid up to Strong Bisimilarity. The other operators are slightly harder to translate.

\section{Helper Operators for \texorpdfstring{$\acptf$}{ACPtf}}

\subsection{Subsets of \texorpdfstring{$A$}{A}}
Working in the language $\acpt$ with the extension of Functional Renaming (written $ACP^{\tau}_{F}$), we start by defining some subsets of $A$ which we will use in our encodings.

\begin{dfn}[Subsets of A]{dfn:sets}{}
   The set $A\in \mathbb{T}$ is the set of all actions.
   \begin{itemize}
      \item $A_{0} \subseteq A$ is the set of actions that actually get used in processes
      \item $A_{T} \subseteq A$ is a set of target actions. This is used in operators such as $\csp$ Parallel Composition, which only communicates over a set.
      \item $H_{0} = A - A_{0}$ is the set of working space operators, or any other action that doesn't get used
      \item $H_{1} = A_{0} \uplus \mathscr{H}$ is the set of actions, plus a set of working operators $\mathscr{H}$
   \end{itemize}

   In general, $A_{T} \subseteq A_{0} \subseteq H_{1} \subseteq A$.

   Note that the silent step is not defined in $A$, and we will define $A_{\tau}$ to be $A \cup \{\tau\}$
\end{dfn}

\import{diagrams/}{triggering.tex}
\subsection{Triggering}
We define an operator $\Gamma(P)$ that emulates the Triggering operator of MEIJE [REFER]. For a trace $a.b.\cdots$ on a process $P$, the triggering operator can be represented as an operator that tags the first action of a process.

First, we define a function $f_{\mathtt{trig}}$ and communications for the operations $\mathtt{first}$ and $\mathtt{next}$.


\begin{multicols}{2}
   \begin{dfn-s}[Communications]{dfn:comm-triggering}{}
      Define communications where
      \begin{align*}
	 a | \mathtt{first} &= a_{\mathtt{first}}\\
	 a | \mathtt{next} &= a_{\mathtt{next}}
      \end{align*}
   \end{dfn-s}

   \begin{dfn}[F1]{dfn:f1}{}
      Define functions $f_{\mathtt{trig}}: A \to A$ where
      \begin{align*}
	 f_{\mathtt{trig}}(a_{\mathtt{first}}) &= a_{\mathtt{ini}} \\
	 f_{\mathtt{trig}}(a_{\mathtt{next}}) &= a 
      \end{align*}
   \end{dfn}
\end{multicols}

We use the notation of $a^{\infty}$ as syntactic sugar to mean $\langle X \mid X = a.X \rangle$. Using the sets defined in \ref{dfn:sets}, we can now define $\Gamma(P)$ as such:

\begin{dfn}[Triggering in ACP]{dfn:acp-triggering}{}
   \[\Gamma(P) := f_{\mathtt{trig}}\bigl[\partial_{H_{1}}(P \pcomp \mathtt{first}.(\mathtt{next}^{\infty}))\bigr]\]
   is an operator that turns a trace of a process $P$, $a.b.c.\dots$ into the trace
   \[a_{\mathtt{ini}}. b. c. \dots\]
\end{dfn}

This works in the following method:
\vspace{-5pt}
\begin{enumerate}[label=\alph*)]
   \item Merge the process $P$ with the process $\mathtt{first}.\mathtt{next}.\mathtt{next}\dots$. Via Def \ref{dfn:comm-triggering}, this will produce a lattice of $P$ and $\mathtt{first}.(\mathtt{next}^{\infty})$, with communications on every square, but most importantly, a chain of communications going down the centre of the form.
      \begin{equation}\label{eq:fnn}
	 a_{\mathtt{first}}. b_{\mathtt{next}} . c_{\mathtt{next}} \dots
      \end{equation}
   \item Restrict the actions in $H_{1}$. Since all the actions in $P, \mathtt{first}.(\mathtt{next}^{\infty}) \in H_{1}$ this effectively restricts both sides of the left merge, leaving only communications from the initial state. This leaves equation \ref{eq:fnn} as the only remaining trace.
   \item Apply $f_{\mathtt{trig}}$ to equation \ref{eq:fnn}. Via \ref{dfn:f1}, the final result is
      \begin{equation}\label{eq:gamma-result}
	 a_{\mathtt{ini}}. b . c \dots
      \end{equation}

      The process is now exactly as stated in Definition \ref{dfn:acp-triggering}.
\end{enumerate}
Note that since $\tau\not\in A$, $\partial_{H_{1}}$ will not restrict $\tau$, and additionally since $\tau$ does not communicate with any actions, Step 2 effectively becomes any amount of $\tau$ steps followed by the diagonal trace immediately following that. This results in cases $\Gamma(P)$ where $P = \tau.b.c\dots$ becoming the trace
\[\tau.b_{\mathtt{ini}}.c.\dots\]
effectively skipping $\tau$'s, then acting the same as processes that don't start with a $\tau$.

\import{diagrams/}{triggering-tau.tex}

\newpage
\subsection{Associativity and Postfix Function}
From the axioms of $\acpt$ \citep{bergstraACPtUniversalAxiom1989}, we have the following axioms of associativity with the communication operator $\mid$ shown in the table below:

\begin{table}[h!]
    \centering
    \begin{tabular}{ |c| }
       \hline
       \textbf{Communication function in $\acpt$}\\
       \hline
       $a | b = b | a$ \\
       $(a | b) | c = a | (b | c)$ \\
       $\delta | a = \delta$\\
       \hline
    \end{tabular}
    \caption{Axioms of $\acpt$ Communication}
    \label{table:acpt-communication}
\end{table}

Bearing the above axioms in mind, we have the potential to run into problems with this with our communications. For example, in the proposed translation for the External Choice operator $\square$ (\ref{ssec:external-choice}), a simplified version of the translation would have the following communications:
\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \qquad a_{\mathtt{first}} | \mathtt{choose} = a\]
This might work at first glance, but the Associativity axiom does not hold true in this case, such as in the following counterexample:
\begin{align*}
   a | \mathtt{first} | \mathtt{choose} &= (a | \mathtt{first}) | \mathtt{choose} = a_{\mathtt{first}} | \mathtt{choose} = a \\
					&= a | (\mathtt{first} | \mathtt{choose}) = a | \delta = \delta
\end{align*}
From this example, it is clear that the proposed communications would not satisfy the axioms of $\acpt$. It is for this reason that in \ref{dfn:f1}, we have the rule
\[f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{ini}} \qquad \text{instead of} \qquad f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{first}}\]
A preferred communications function is as follows:
\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \qquad a_{\mathtt{ini}} | \mathtt{choose} = a\]
\begin{align*}
   a | \mathtt{first} | \mathtt{choose} &= (a | \mathtt{first}) | \mathtt{choose} = a_{\mathtt{first}} | \mathtt{choose} = \delta \\
					&= a | (\mathtt{first} | \mathtt{choose}) = a | \delta = \delta
\end{align*}
It is important to note that this scenario would never actually occur in practice, since $\Gamma(P)$ takes precedence and hence $\mathtt{first} | \mathtt{choose}$ would never happen, but the communication function must work over every action regardless of whether it will get used in practice.

\begin{lma}[Keeping Associativity in Communications]{lma:communication-leftside}{}
   For three actions $a,b,c\in A$, if $a | b = c$, then if $c$ does not appear on the left-hand side of any other communication, Associativity will be satisfied.
\end{lma}
\begin{proof}
   WIP. QED
\end{proof}

We define a compatibility function to prevent issues with associativity. Via \ref{lma:communication-leftside}, define a tag $a_{\mathtt{post}}$ which will act as $c$ for all our communications, which satisfies the Lemma. Then, our final step will be to rename $a_{post}$ back to $a$ for any affected actions. This works in the following way:
\[a \xrightarrow{\text{Rename for Communication}} a_{\mathtt{tag}} \xrightarrow{\text{Communicate with an action}} a_{\mathtt{post}} \xrightarrow{\text{Rename for final result}} a\]

\begin{dfn}[Postfix function]{dfn:postfix}{}
   Let $f_{\mathrm{post}} : A \to A$ where
   \vspace{-5pt}
   \[f_{\mathrm{post}}(a_{\mathtt{post}}) = a \quad f_{\mathrm{post}}( \alpha) = \alpha\]
\end{dfn}

\newpage
\section{Translations for the remaining \texorpdfstring{$\csp$}{CSP} Operators}

\subsection{Communications and Functional Renaming}

We define communications for our translation in addition to the ones previously defined for our helper functions. These are defined as follows:

\begin{dfn}[Helper Functions]{dfn:helper-functions}{}
   In addition to the function $\fdef{trig}$ defined in \ref{dfn:f1}, and the postfix function defined in \ref{dfn:postfix}:
   \vspace{-8pt}
   \[
      f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{ini}} \qquad 
      f_{\mathtt{trig}}(a_{\mathtt{next}}) = a  \qquad
      f_{\mathrm{post}}(a_{\mathtt{post}}) = a \qquad f_{\mathrm{post}}( \alpha) = \alpha
   \]
   We define functions for the remaining operators below. We use the notation $A_{T}$ to signify a target set, as used in \ref{ssec:parallel-composition}, \ref{ssec:interrupt}, and $\lambda$ to signify actions in $A_{T}$

   \begin{enumerate}
       \item $\fdef{syn} : A \to A$ is a function that renames any actions in the target set $A_{T}$. This is used in the translation of Parallel Composition (\ref{ssec:parallel-composition})
	  \vspace{-5pt}
	\[\fdef{syn}(\lambda) = \lambda_{\mathtt{syn}} \quad \fdef{syn}(
	\alpha) = \alpha\]
	 \vspace{-30pt}
     \item $\fdef{origin} : A \to A$ is a function that renames actions in a process for use in operators. This is used in the translation of the Stopping operator (\ref{ssec:stopping})
	\vspace{-5pt}
	\[\fdef{origin}(a) = a_{\mathtt{origin}}\]
	 \vspace{-30pt}
     \item $\fdef{split} : A \to A$ is a function that renames actions in a process for use in operators, and also renames actions in the target set $A_{T}$. This is used in the translation of the Interrupt operator (\ref{ssec:interrupt})
	\vspace{-5pt}
	\[\fdef{split}(\lambda) = \lambda_{\mathtt{split}}\qquad \fdef{split}(a) = a_{\mathtt{origin}}\]
   \end{enumerate}
\end{dfn}
\begin{dfn}[Communications]{dfn:communications}{}
   In addition to the communications for the Triggering operator defined in \ref{dfn:comm-triggering}
   \vspace{-5pt}
   \[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \]
   \vspace{-5pt}
   we define additional communications for the functions defined above:

   \begin{enumerate}[leftmargin=*]
      \item $a_{\mathtt{syn}} | a_{\mathtt{syn}} = a_{\mathtt{post}}$. This is used in the translation of Parallel Composition (\ref{ssec:parallel-composition})
      \item $a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}$. This is used in the translation of External choice (\ref{ssec:external-choice})
      \item $a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}}$. This is used in the translation of Stopping and Interrupt operator (\ref{ssec:stopping}, \ref{ssec:interrupt})
      \item $a_{\mathtt{ini}} | \mathtt{split} = a_{\mathtt{post}}$. This is used in the translation of the Stopping operator (\ref{ssec:interrupt})
      \item $a_{\mathtt{split}} | \mathtt{split} = a_{\mathtt{post}}$. This is used in the translation of the Interrupt operator (\ref{ssec:interrupt})
   \end{enumerate}
\end{dfn}



\subsection{Parallel Composition}\label{ssec:parallel-composition}
The parallel composition $\pcomp_{A}$ is defined with the following rules:
\begin{equation}\label{eq:pcomp-definition}
   \prftree{P \prightarrow{\alpha} P' \quad \scriptstyle(\alpha\not\in A)}{P \pcomp_{A} Q \prightarrow{\alpha} P'\pcomp_{A} Q} \qquad \prftree{Q \prightarrow{\alpha} Q' \quad \scriptstyle(\alpha\not\in A) }{P \pcomp_{A} Q \prightarrow{a} P\pcomp_{A} Q'}\qquad \prftree{P \prightarrow{a} P' \, Q \prightarrow{a} Q'\scriptstyle(\alpha\in A)}{P \pcomp_{A} Q \prightarrow{a} P' \pcomp_{A} Q'}
\end{equation}
In other words, a left merge action can be taken by all actions of $P$ and $Q$, which is the same as the $\acptf$ equivalent of parallel composition with the one difference being that in $\csp$, the action must be the same in $P$ and $Q$, whereas in $\acptf$ the action is defined with a communication function. For our encoding, we take $\mathscr{H} = \{\}$, and therefore $H_{1} = A_{0}$. The goal is to tag actions in the target set $A_{T}$, and then define a communication function between identical marked actions. We can do this via the following functions and communications:

\begin{dfn}[Functions and Communications - Parallel Composition]{dfn:comms-pcomp}{}
   As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined over Parallel Composition:
	\[\fdef{syn}(\lambda) = \lambda_{\mathtt{syn}} \quad \fdef{syn}(
	\alpha) = \alpha  \qquad f_{\mathrm{post}}(a_{\mathtt{post}}) = a \qquad f_{\mathrm{post}}( \alpha) = \alpha\]
	\[a_{\mathtt{syn}} | a_{\mathtt{syn}} = a_{\mathtt{post}}\]

\end{dfn}


A translation for Parallel Composition can then be written as the following:
\[\trans{P \pcomp_{A} Q} = \partial_{H_{0}}(f_{\mathrm{post}}(\fdef{syn}(\trans{P}) \pcomp \fdef{syn}(\trans{Q}))) \]

\subsection{External choice}\label{ssec:external-choice}


The external choice operator $\square$ is defined with the following rules:
\begin{equation}\label{eq:csp-definition}
	\prftree{P \prightarrow{a} P'}{P \square Q \prightarrow{a} P'} \qquad \prftree{Q \prightarrow{a} Q'}{P \square Q \prightarrow{a} Q'} \qquad \prftree{P \prightarrow{\tau} P'}{P \square Q \prightarrow{\tau} P' \square Q} \qquad \prftree{Q \prightarrow{\tau} Q'}{P \square Q \prightarrow{a} P \square Q'}
\end{equation}
In other words, we can take an external choice by the user, and additionally an internal action will still let an external choice be made after the internal move has been made. This differs from the $\acptf$ Alternative Choice operator ($+$), as $+$ will not let you select externally if an internal action is made. For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{choose}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{choose}\}$ as defined in Definition \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - External Choice]{dfn:comms-external}{}
   As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined over External Choice:
   \[f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{ini}} \qquad 
      f_{\mathtt{trig}}(a_{\mathtt{next}}) = a  \qquad
      f_{\mathrm{post}}(a_{\mathtt{post}}) = a \qquad f_{\mathrm{post}}( \alpha) = \alpha
\]
\[
   a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}
\]
\longrule{0.08ex}

Additionally, recall that the Triggering operator (\ref{dfn:acp-triggering}) is defined as:
\[\Gamma(P) := f_{\mathtt{trig}}[\partial_{H_{1}}(P \pcomp \mathtt{first}(\mathtt{next}^{\infty}))])\]
\end{dfn}


We can then define an encoding of the $\csp$ external choice operator $\square$ in $\acptf$ in the following equation
\[\trans{P \square Q} = \partial_{H_{0}}\Bigl(f_{2}\Bigl[\Gamma[\trans{P}]\, \pcomp \,\mathtt{choose}\, \pcomp \,\Gamma[\trans{Q}]\Bigl]\Bigr)\]

\subsection{Stopping}\label{ssec:stopping}

The stopping operator $\triangle$ is defined with the following rules:

\[\prftree{P \prightarrow{\alpha} P'}{P \triangle Q \prightarrow{\alpha} P' \triangle Q} \qquad \prftree{Q \prightarrow{\tau} Q'}{P \triangle Q \prightarrow{\tau} P \triangle Q'} \qquad \prftree{Q \prightarrow{a} Q'}{P \triangle Q \prightarrow{a} Q'}\]

In other words, we can take an external choice from $P$ without interrupting the operator, in addition to internal choices from $Q$. However, the moment an external choice is made from $Q$, the process can then never return to $P$.

For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - Stopping]{dfn:comms-stopping}{}
   As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined over External Choice:
   \[f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{ini}} \qquad 
      f_{\mathtt{trig}}(a_{\mathtt{next}}) = a  \qquad
      f_{\mathrm{post}}(a_{\mathtt{post}}) = a \qquad f_{\mathrm{post}}( \alpha) = \alpha
\]
\[\fdef{origin}(a) = a_{\mathtt{origin}}\]
\[a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}} \qquad a_{\mathtt{ini}} | \mathtt{split} = a_{\mathtt{post}}
\]

\longrule{0.08ex}

Additionally, recall that the Triggering operator (\ref{dfn:acp-triggering}) is defined as:
\[\Gamma(P) := f_{\mathtt{trig}}[\partial_{H_{1}}(P \pcomp \mathtt{first}(\mathtt{next}^{\infty}))])\]
\end{dfn}

We can now define an encoding of the $\csp$ Stopping operator $\triangle$ in $\acptf$. We start off with a new process, which we will call $\Pi$. This is defined as the process
\[\Pi = \langle X \mid X = \mathtt{origin}.X + \mathtt{split} \rangle\]
Or, visualised as a process graph:
% https://q.uiver.app/#q=WzAsMyxbMSwwLCJcXGNpcmMiXSxbMywwLCJcXGJ1bGxldCJdLFswLDBdLFswLDEsIlxcbWF0aHR0e3NwbGl0fSJdLFswLDAsIlxcbWF0aHR0e29yaWdpbn0iXSxbMiwwLCIiLDAseyJzaG9ydGVuIjp7InNvdXJjZSI6NTB9fV1d
\[\begin{tikzcd}[column sep=scriptsize, row sep=scriptsize]
	{} & \circ && \bullet
	\arrow[shorten <=8pt, from=1-1, to=1-2]
	\arrow["{\mathtt{origin}}", from=1-2, to=1-2, loop, in=55, out=125, distance=10mm]
	\arrow["{\mathtt{split}}", from=1-2, to=1-4]
\end{tikzcd}\]

From this, an encoding can be written in the following way:
\[\trans{P \triangle Q} = \partial_{H_{0}}\Bigl(f_{\mathtt{post}}\Bigl[ \bigl(f_{\mathtt{origin}}(\trans{P}) \pcomp \Pi\bigr) \pcomp \Gamma(\trans{Q}) \Bigr]\Bigr)\]
\subsection{Interrupt}\label{ssec:interrupt}

The interrupt operator $\interrupt$ is defined with the following rules:

\[\prftree{P \prightarrow{\alpha} P' \quad \scriptstyle(a\not\in A)}{P \interrupt Q \prightarrow{\alpha} P' \interrupt Q} \qquad \prftree{P \prightarrow{a} P' \quad \scriptstyle(a\in A)}{P \interrupt Q \prightarrow{a} Q }\]

In other words, we can take as many actions in $P$ as we want, as long as they aren't contained in a set of actions, which we will call $A_{T}$. However, the moment an action in $A_{T}$ is made, The process then diverts to $Q$. This can be also throught as an error checking operator. Similarly to the stopping operator, for our encoding, we take 
\[\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}\]
, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - Interrupt]{dfn:comms-interrupt}{}
   As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined over External Choice:
   \[f_{\mathrm{post}}(a_{\mathtt{post}}) = a \qquad f_{\mathrm{post}}( \alpha) = \alpha  \qquad \fdef{split}(\lambda) = \lambda_{\mathtt{split}}\qquad \fdef{split}(a) = a_{\mathtt{origin}}\]
\[a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}} \qquad a_{\mathtt{split}} | \mathtt{split} = a_{\mathtt{post}}\]
\end{dfn}

We can now define an encoding of the $\csp$ Interrupt operator $\interrupt$ in $\acptf$. We employ the use of the same operator as in the Stopping operator, $\Pi$ which is defined as
\[\Pi = \langle X \mid X = \mathtt{origin}.X + \mathtt{split} \rangle\]
Or, visualised as a process graph:
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXGNpcmMiXSxbMiwwLCJcXGJ1bGxldCJdLFs0LDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxtYXRodHR7b3JpZ2lufSJdLFsxLDEsIlxcbWF0aHR0e29yaWdpbn0iXSxbMSwyLCJcXG1hdGh0dHtzcGxpdH0iXSxbMiwyLCJcXG1hdGh0dHtzcGxpdH0iXV0=
\[\begin{tikzcd}[column sep=scriptsize, row sep=scriptsize]
	{} & \circ && \bullet
	\arrow[shorten <=8pt, from=1-1, to=1-2]
	\arrow["{\mathtt{origin}}", from=1-2, to=1-2, loop, in=55, out=125, distance=10mm]
	\arrow["{\mathtt{split}}", from=1-2, to=1-4]
\end{tikzcd}\]

From this, an encoding can be written in the following way:
\[\trans{P \interrupt Q} = \partial_{H_{0}}\Bigl(f_{\mathtt{post}}\Bigl[ f_{\mathtt{split}}(\trans{P}) | | \Pi.\trans{Q} \Bigr]\Bigr)\]

% https://q.uiver.app/#q=WzAsMjUsWzAsMCwiXFxidWxsZXQiXSxbMiwwLCJcXGJ1bGxldCJdLFs0LDAsIlxcYnVsbGV0Il0sWzAsMiwiXFxidWxsZXQiXSxbMCw0LCJcXGJ1bGxldCJdLFswLDYsIlxcYnVsbGV0Il0sWzAsOCwiXFxidWxsZXQiXSxbNiwwLCJcXGJ1bGxldCJdLFs4LDAsIlxcYnVsbGV0Il0sWzIsMiwiXFxidWxsZXQiXSxbNCwyLCJcXGJ1bGxldCJdLFs2LDIsIlxcYnVsbGV0Il0sWzgsMiwiXFxidWxsZXQiXSxbMiw0LCJcXGJ1bGxldCJdLFs0LDQsIlxcYnVsbGV0Il0sWzYsNCwiXFxidWxsZXQiXSxbOCw0LCJcXGJ1bGxldCJdLFsyLDYsIlxcYnVsbGV0Il0sWzQsNiwiXFxidWxsZXQiXSxbNiw2LCJcXGJ1bGxldCJdLFs4LDYsIlxcYnVsbGV0Il0sWzIsOCwiXFxidWxsZXQiXSxbNCw4LCJcXGJ1bGxldCJdLFs2LDgsIlxcYnVsbGV0Il0sWzgsOCwiXFxidWxsZXQiXSxbMCwxLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMSwyLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMCwzLCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMyw0LCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbNCw1LCJiX3tcXG1hdGh0dHtzcGxpdH19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFs1LDYsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsyLDcsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzcsOCwicV8xIl0sWzEsOSwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzIsMTAsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFs3LDExLCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbOCwxMiwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzksMTMsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxMCwxNCwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzExLDE1LCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMTIsMTYsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxMywxNywiYl97XFxtYXRodHR7c3BsaXR9fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMTQsMTgsImJfe1xcbWF0aHR0e3NwbGl0fX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzE1LDE5LCJiX3tcXG1hdGh0dHtzcGxpdH19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxNiwyMCwiYl97XFxtYXRodHR7c3BsaXR9fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMTcsMjEsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxOCwyMiwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzE5LDIzLCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMjAsMjQsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFszLDksIlxcbWF0aHR0e29yaWdpbn0iLDAseyJjb2xvdXIiOlswLDAsNDNdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDAsNDMsMV1dLFs5LDEwLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMTAsMTEsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzExLDEyLCJxXzEiXSxbNCwxMywiXFxtYXRodHR7b3JpZ2lufSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzEzLDE0LCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMTQsMTUsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzE1LDE2LCJxXzEiXSxbNSwxNywiXFxtYXRodHR7b3JpZ2lufSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzE3LDE4LCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMTgsMTksIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzE5LDIwLCJxXzEiXSxbNiwyMSwiXFxtYXRodHR7b3JpZ2lufSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzIxLDIyLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMjIsMjMsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzIzLDI0LCJxXzEiXSxbMCw5LCJhIl0sWzksMTQsImEiXSxbMTQsMTksImIiXSxbMywxMywiYSJdLFsxLDEwLCJhIl0sWzUsMjEsImEiXSxbMTcsMjIsImEiXV0=
\[\begin{tikzcd}[cramped, column sep=scriptsize]
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=1-1, to=1-3]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-1, to=3-1]
	\arrow["a", from=1-1, to=3-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=1-3, to=1-5]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-3, to=3-3]
	\arrow["a", from=1-3, to=3-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=1-5, to=1-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-5, to=3-5]
	\arrow["{q_1}", from=1-7, to=1-9]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-7, to=3-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-9, to=3-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=3-1, to=3-3]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-1, to=5-1]
	\arrow["a", from=3-1, to=5-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=3-3, to=3-5]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-3, to=5-3]
	\arrow["a", from=3-3, to=5-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=3-5, to=3-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-5, to=5-5]
	\arrow["{q_1}", from=3-7, to=3-9]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-7, to=5-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-9, to=5-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=5-1, to=5-3]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-1, to=7-1]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=5-3, to=5-5]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-3, to=7-3]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=5-5, to=5-7]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-5, to=7-5]
	\arrow["b", from=5-5, to=7-7]
	\arrow["{q_1}", from=5-7, to=5-9]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-7, to=7-7]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-9, to=7-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=7-1, to=7-3]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-1, to=9-1]
	\arrow["a", from=7-1, to=9-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=7-3, to=7-5]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-3, to=9-3]
	\arrow["a", from=7-3, to=9-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=7-5, to=7-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-5, to=9-5]
	\arrow["{q_1}", from=7-7, to=7-9]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-7, to=9-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-9, to=9-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=9-1, to=9-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=9-3, to=9-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=9-5, to=9-7]
	\arrow["{q_1}", from=9-7, to=9-9]
\end{tikzcd}\]

\subsection{Sliding Choice}\label{ssec:sliding-choice}
The sliding choice, or sliding operator $\triangleright$ is defined with the following rules:

\[\prftree{P \prightarrow{a} P'}{P \triangleright Q \prightarrow{a} P'} \qquad \prftree{P \prightarrow{\tau} P'}{P \triangleright Q \prightarrow{\tau} P' \triangleright Q} \qquad P \triangleright Q \prightarrow{\tau} Q\]

In other words, this operator lets you take an external action on $P$, however there is a second process that may at any point before the external action taken in $P$ ``time out'' and move to $Q$ instead.

{\huge WIP}

\newpage
\subsection{Final Translation}

\begin{align*}
   P, Q ::= &\mathrm{STOP} \mid \mathrm{div} \mid a\to P \mid P \sqcap Q \mid P \extchoice Q \mid P \triangleleft Q \mid \\
	&P | |_{A} Q \mid P \backslash A \mid f(P) \mid P \triangle Q \mid P \theta_{A} Q \mid 
\end{align*}

We define our translation

\begin{dfn}[Translation of CSP to ACP]{dfn:trans}{}
   Let $\tcsp$ be the expressions in the language $\csp$, and $\tacp$ be expressions in the language $\acptf$. We define a translation $\tran : \tcsp \to \tacp$ defined as such:
   \begin{align*}
      \trans{STOP} &= \delta \\
   \trans{\mathrm{div}} &= \langle X \mid X = \tau.X \rangle \\
      \trans{a \to P} &= a.\trans{P} \\
   \trans{P \intchoice Q} &= \tau.\trans{P} + \tau.\trans{Q} \\
   \trans{P \extchoice Q} &= \partial_{H_{0}}\Bigl(f_{2}\Bigl[\Gamma[\trans{P}]\, \pcomp \,\mathtt{choose}\, \pcomp \,\Gamma[\trans{Q}]\Bigl]\Bigr) \\
   \trans{P \pcomp_{A} Q} &= \partial_{H_{0}}(f_{\mathrm{post}}(f_{2}(\trans{P}) \pcomp f_{2}(\trans{Q}))) \\
      \trans{P \backslash A} &= \partial_{A}{\trans{P}} \\
   % \trans{\mu p.P} &= \langle X \mid X = \tau.X \rangle
   \trans{f(P)} &= f(\trans{P}) \\
      \trans{P \triangle Q} &= \partial_{H_{0}}\Bigl(f_{\mathtt{post}}\Bigl[ \bigl(f_{\mathtt{origin}}(\trans{P}) \pcomp \Pi\bigr) \pcomp \Gamma(\trans{Q}) \Bigr]\Bigr) \\
      \trans{P \interrupt Q} &= \partial_{H_{0}}\Bigl(f_{\mathtt{post}}\Bigl[ f_{\mathtt{split}}(\trans{P}) | | \Pi.\trans{Q} \Bigr]\Bigr)
   \end{align*}
\end{dfn}

\newpage
\chapter{Validity of the Encoding}

\section{External Choice}
On a process without $\tau$, the function
\[\partial_{H_{0}}\Bigl(f_{2}\Bigl[\Gamma(P)\, | | \,\mathtt{choose}\, | | \,\Gamma(Q)\Bigr]\Bigr)\]
has identical behaviour to $P + Q$

On processes with internal actions, which we will call $\mathcal{P} = \tau_{P}.a.P$ and $\mathcal{Q} = \tau_{Q}.b.Q$, where $\tau_{P}$ indicates the number of starting $\tau$ actions in the process, possibly 0, the $\tau$ cannot communicate with $\mathtt{choose}$ so $\mathtt{choose}$ will only communicate with $a$ (Since only $a$ will be labelled with $\mathtt{first}$). However, the first action of $Q$ will still have the name $b_{\mathtt{first}}$ for $b\in A$. This lets the function effectively skip the $\tau$, then perform $\mathtt{choose}$ on $a.P \,| | \,b.Q$ which matches the behaviour of $\csp$ $\square$. 

However, this translation is not strongly bisimilar. This is due to the final restriction $\partial_{H_{0}}$, which will usually restrict any stray $a_{\mathtt{first}}$ actions (and subsequent actions/processes) that try to communicate. However, since the silent step $\tau$ is not in $A$, we will get left with stray $\tau$ actions. This doesn't hold for two processes $a.P$ and $\tau.Q$, since the translation would yield the process
\[a.(\tau | | P) + \tau.(P + Q) \ne a.P + \tau.(P + Q)\]

% \begin{figure}[t!]
% 	\centering
% 	% https://q.uiver.app/#q=WzAsNyxbMCwwLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzIsMCwiXFxidWxsZXQiXSxbMCwxLCJcXGJ1bGxldCJdLFsxLDEsIlxcYnVsbGV0Il0sWzIsMSwiXFxidWxsZXQiXSxbMywxLCJcXGJ1bGxldCJdLFswLDEsImEiXSxbMSwyLCJhIl0sWzMsNCwiYSJdLFs0LDUsIlxcdGF1Il0sWzUsNiwiYSJdLFswLDMsIiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsNCwiIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNSwxLCIiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsyLDYsIiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
% 	\[\begin{tikzcd}[cramped]
% 		\bullet & \bullet & \bullet \\
% 		\bullet & \bullet & \bullet & \bullet
% 		\arrow["a", from=1-1, to=1-2]
% 		\arrow[dashed, no head, from=1-1, to=2-1]
% 		\arrow["a", from=1-2, to=1-3]
% 		\arrow[dashed, no head, from=1-2, to=2-2]
% 		\arrow[dashed, no head, from=1-3, to=2-4]
% 		\arrow["a", from=2-1, to=2-2]
% 		\arrow["\tau", from=2-2, to=2-3]
% 		\arrow[dashed, no head, from=2-3, to=1-2]
% 		\arrow["a", from=2-3, to=2-4]
% 	\end{tikzcd}\]
% 	\caption{Branching Bisimilarity}
% 	\label{branching-bisim}
% \end{figure}

\vspace{-5pt}
\begin{figure}[!ht]
	\centering
% https://q.uiver.app/#q=WzAsMTMsWzAsMCwiXFxjaXJjIl0sWzQsMCwiXFxidWxsZXQiXSxbNiwwLCJcXGJ1bGxldCJdLFswLDIsIlxcYnVsbGV0Il0sWzYsMiwiXFxidWxsZXQiXSxbNCwyLCJcXGJ1bGxldCJdLFs2LDQsIlxcYnVsbGV0Il0sWzgsMiwiXFxidWxsZXQiXSxbMiwyLCJcXGJ1bGxldCJdLFsyLDQsIlxcYnVsbGV0Il0sWzQsNCwiXFxidWxsZXQiXSxbMyw0LCJcXGJ1bGxldCJdLFs4LDQsIlxcYnVsbGV0Il0sWzAsMSwiXFx0YXUiXSxbMCwzLCJhX1xcdGV4dHtmaXJzdH0iLDIseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxLDQsIlxcdGV4dHtjaG9vc2V9IiwxLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbMSw1LCJhX1xcdGV4dHtmaXJzdH0iLDIseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFs0LDYsImFfXFx0ZXh0e2ZpcnN0fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzUsNiwiXFx0ZXh0e2Nob29zZX0iLDEseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxLDYsImEiXSxbNCw3LCJiX1xcdGV4dHtmaXJzdH0iLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFswLDgsIlxcdGV4dHtjaG9vc2V9IiwxLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbOCw5LCJhX1xcdGV4dHtmaXJzdH0iLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFszLDksIlxcdGV4dHtjaG9vc2V9IiwxLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbMCw5LCJhIl0sWzIsNywiXFx0ZXh0e2Nob29zZX0iLDEseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxLDIsImJfXFx0ZXh0e2ZpcnN0fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzEsNywiYiJdLFs5LDExLCJcXHRhdSJdLFsxMSwxMCwiYl9cXHRleHR7Zmlyc3R9IiwwLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbNiwxMiwiYl9cXHRleHR7Zmlyc3R9IiwwLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbNywxMiwiYV9cXHRleHR7Zmlyc3R9IiwwLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXV0=
\[\begin{tikzcd}[cramped]
	\circ &&&& \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	&& \bullet & \bullet & \bullet && \bullet && \bullet
	\arrow["\tau", from=1-1, to=1-5]
	\arrow["{a_\text{first}}"', color={rgb,255:red,214;green,92;blue,92}, from=1-1, to=3-1]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=1-1, to=3-3]
	\arrow["a", from=1-1, to=5-3]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=1-5, to=1-7]
	\arrow["{a_\text{first}}"', color={rgb,255:red,214;green,92;blue,92}, from=1-5, to=3-5]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=1-5, to=3-7]
	\arrow["b", from=1-5, to=3-9]
	\arrow["a", from=1-5, to=5-7]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=1-7, to=3-9]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=3-1, to=5-3]
	\arrow["{a_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-3, to=5-3]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=3-5, to=5-7]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-7, to=3-9]
	\arrow["{a_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-7, to=5-7]
	\arrow["{a_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-9, to=5-9]
	\arrow["\tau", from=5-3, to=5-4]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=5-4, to=5-5]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=5-7, to=5-9]
\end{tikzcd}\]
	\caption{Counterexample for Strong Bisimilarity with the processes $P = a$ and $Q = \tau.b$. The result of the translation is $a.\tau + \tau.(a+b) \not\leftrightarroweq a + \tau.(a+b)$. Restricted actions are marked in red.}
	\label{fig:sb-counterexample}
\end{figure}


We define formally the definition of Rooted Branching Bisimulation via \citep{baetenProcessAlgebra1990}:

\begin{dfn}[Rooted Branching Bisimilarity]{dfn:rbb}{}
	Let $P$ and $Q$ be two processes, and $R$ be a relation between nodes of $P$ and nodes of $Q$. $R$ is a \textbf{Branching Bisimulation} between $P$ and $Q$ if:
	\begin{enumerate}
		\item The roots of $P$ and $Q$ are related by $R$
		\item If $s \prightarrow{a} s'$ for $a\in A \cup \{\tau\}$ is an edge in $P$, and $s R t$, then either
			\begin{enumerate}[label=\alph*)]
			    \item $a= \tau$ and $s' R t$
			    \item $\exists t \Rightarrow t_{1} \prightarrow{a} t'$ such that $s R t_{1}$ and $s R t'$
			\end{enumerate}
		\item If $s \downarrow$ and $s R t$ then there exists a path $t \Rightarrow t'$ in $Q$ to a node $t'$ with $t'\downarrow$ and $s R t'$
		\item[4, 5]: As in $2, 3$, with the roles of $P$ and $Q$ interchanged
	\end{enumerate}

	\longrule{0.08ex}

	$R$ is called a \textbf{Rooted Branching Bisimulation} if the following root condition is satisfied:
	\begin{itemize}
	    \item If $\mathrm{root}(P) \prightarrow{a} s'$ for $a\in A \cup \{\tau\}$, then there is a $t'$ with $\mathrm{root}(Q)\prightarrow{a} t'$ and $s' R t'$
	    \item If $\mathrm{root}(Q) \prightarrow{a} t'$ for $a\in A \cup \{\tau\}$, then there is a $s'$ with $\mathrm{root}(P)\prightarrow{a} s'$ and $s' R t'$
	    \item $\mathrm{root}(g)\downarrow$ iff $\mathrm{root}(h)\downarrow$
	\end{itemize}
\end{dfn}

In other words, two processes are Rooted Branching Bisimilar if it is strongly bisimilar for the first step, and branching bisimilar for the remaining ones. This is a more desirable outcome because RBB is a congruence \citep{fokkinkRootedBranchingBisimulation2000}.

We can now work towards a proof that the external choice is Rooted Branching Bisimilar.

\newpage


\begin{dfn}[The translation]{dfn:the-translation}{}
\[\trans{P \square Q} = \partial_{H_{0}}\Bigl(f_{1}\Bigl[\Gamma[\trans{P}]\, | | \,\mathtt{choose}\, | | \,\Gamma[\trans{Q}]\Bigl]\Bigr)\]
\end{dfn}

\begin{dfn}[Communications]{dfn:the-comms}{}
	From \ref{dfn:comms-external}:
	\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \qquad a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}\]
		
\end{dfn}


\begin{lma}[]{lma:tau-transform}{}
	For processes $P, P'\in \csp$, if $P \prightarrow{\tau} P'$ then $\Gamma[\trans{P}] \prightarrow{\tau} \Gamma[\trans{P'}]$. Alternatively,
	\[\Gamma[\trans{P}] = \tau. \Gamma[\trans{P'}]\]
\end{lma}

\begin{proof}
	Something about how $\tau$'s do not get affected by the gamma function.
\end{proof}

\begin{lma}[]{lma:a-transform}{}
	For processes $P, P'\in \csp$, if $P \prightarrow{a} P'$ then for any action $a \in A_{0}$ we have 
	\[
		(\Gamma[\trans{P}]\, | | \, \mathrm{choose}) \prightarrow{a} \trans{P'} \quad \text{ and } \quad 
		(\mathrm{choose}\, | | \, (\Gamma[\trans{P}]) \prightarrow{a} \trans{P'}
	\]
	and
\end{lma}

\begin{proof}
	Directly follows from communications
\end{proof}

\begin{lma}[]{lma:stagnant-inis}{}
	For processes $a.P\in \csp$ where $a\in A_{0}$, if there exists a process $b.P'$ where $b\in A_{0}$ we have 
	
	\[\partial_{H_{0}} (b.P' \,| | \, \Gamma[\trans{a.P}]) = \trans{b.P'} \]
\end{lma}

\begin{proof}
	The $\Gamma$ function turns a process into a process equation of the form
	\[a_{\mathtt{ini}}.b.c\cdots\]
	the process $a_{\mathtt{ini}}$ does not communicate with anything other than $\mathtt{choose}$ which is not in $A_{0}$. Therefore, the restriction operator will remove all the $\Gamma$ left merges, leaving $b.P'$
\end{proof}

\newpage
\begin{lma}[]{lma:tau-on-p-process}{}
	For a process $\tau^{*}.a.P\in \csp$, where $\tau^{*}$ indicates a chain of $\tau$, possibly $0$, and $a\in A_{0}$, if there exists a process $Q\in \acptf$ where $b\in A_{0}$ for all actions $b$, we have 
	
	\begin{align*}
	   \partial_{H_{0}} (Q\,| | \Gamma[\trans{\tau^{*}.a.P}]) &= \partial_{H_{0}} (Q\,| | \tau^{*}\Gamma[\trans{a.P}]) \\
											&=(Q\, | | \, \tau^{*})
	\end{align*}
	This resulting process is Branching Bisimilar to $\trans{a.P'}$
\end{lma}

\begin{proof}
   Inductively prove going down to $Q | | \tau$ and showing all is BB
\end{proof}

\newpage
\subsection{Proof of Rooted Branching Bisimilarity [WIP]}

\textbf{FROM CHRIS}
\begin{enumerate}
    \item Given $P \stackrel{a}\to P'$ there must be some operational rule of the form $\frac{P''\:\stackrel{a}\to\:P'}{P \:\stackrel{a}\to\: P'}$, which suggests that there is a $P''$ such that $P'' \stackrel{a}\to P'$.
    \item The process $P''$ has a proof shorter than that of $P$ by one step. Due to the inductive hypothesis, this means that there exists a $q''$ such that $(P'', P'') \in \mathcal B$.
    \item Because $(P'', Q'') \in \mathcal B$ and $P'' \stackrel{a}\to P'$ there must be a $Q'$ such that $Q'' \stackrel{a}\to Q'$ and $(P', Q') \in \mathcal B$.
    \item When a rule of the form $\frac{Q'' \:\stackrel{a}\to\: Q'}{Q\:\stackrel{a}\to\:Q'}$ exists it means $P \stackrel{a}\to P'$ and $(P', Q') \in \mathcal B$ implies the existance of a $Q'$ such that $Q \stackrel{a}\to Q'$, fulfilling the criteria of the bisimulation condition. 
\end{enumerate}



We define a bisimulation relation.
\begin{dfn}[Rooted Branching Bisimulation Relation]{dfn:bisim-relation}{}
   Let $\tcsp$ be the expressions in the language $\csp$, and $\tacp$ be expressions in the language $\acptf$. We use the translation $\tran : \tcsp \to \tacp$ as defined in \ref{dfn:trans}. 

   We now define a Rooted Branching Bisimulation between $\tcsp$ and $\tacp$:
   \[
      \mathcal{B} := \{P, \trans{P} \mid P\in \csp\}
   \]
\end{dfn}

\begin{proof}
	
Let $P, Q \in \csp$ be two processes. WTS $P \square Q =_{\text{RBB}} \trans{P \square Q}$. I.e.: we want to show that any move will result in a process that satisfies RBB. We prove this inductively by showing that any smaller process of $P$ is also Rooted Branching Bisimilar.

Define relation 

% \textbf{Option 1}: $a$ action on $P$. Let $a \in A_{0}$ and $P$ s.t. $P \prightarrow{a} P'$. In the domain of $\csp$, this results in the process
% \[P \square Q \prightarrow{a} P'\]
% and therefore, there exists $P$ such that $P \prightarrow{a} P'$. Therefore, there exists a smaller process $P$ and by the inductive hypothesis, there exists a related process $\trans{P}$ s.t. $P \sim \trans{P}$, and hence an action $\trans{P} \prightarrow{a} \trans{P}'$ and $P' \sim \trans{P}'$. Via our relation $\mathcal{B}$, $P' \sim \trans{P'}$, therefore $\trans{P'} = \trans{P}'$
% 	
% Via Lemma \ref{lma:a-transform}, we can derive the following equation from our translation
% \[\prftree{P \prightarrow{a} P'}{\partial_{H_{0}}\Bigl(f_{1}\Bigl[\Gamma[trans)]\, | | \,\mathtt{choose}\, | | \,\Gamma[trans}]\Bigl]\Bigr} \prightarrow{a} \partial_{H_{0}}\Bigl(f_{1}\Bigl[trans'}\, | | \,\Gamma[trans)]\Bigl]\Bigr}}\]


\textbf{Option 1}: $a$ action on $P$. Let $a \in A_{0}$ and $P'\in \mathrm{CSP}$ s.t. $P \prightarrow{a} P'$. In the domain of CSP, this results in the process

		\[P \square Q \prightarrow{a} P'\]
	
	Via Lemma \ref{lma:a-transform}, we can now derive the following equation
	\[\trans{P \square Q} = \partial_{H_{0}}\Bigl(f_{1}\Bigl[\Gamma[\trans{P}]\, | | \,\mathtt{choose}\, | | \,\Gamma[\trans{Q}]\Bigl]\Bigr) \prightarrow{a} \partial_{H_{0}}\Bigl(f_{1}\Bigl[\trans{P'}\, | | \,\Gamma[\trans{Q}]\Bigl]\Bigr)\]
      




      This is not yet a process that is comparable to $\trans{P'}$, so we look at the next step.
\begin{enumerate}
	\item \textbf{Case 1}: $\exists b\in A_{0}$ and $Q'\in \csp$ s.t. $Q \prightarrow{b} Q'$. Then via Lemma \ref{lma:stagnant-inis}, this results in
		\[\trans{P'} = \partial_{H_{0}}(f_{1}[\trans{P'}]) = \trans{P'}\]
		Which is strongly bisimilar.
	\item \textbf{Case 2}: $Q \prightarrow{ \tau} Q'$. Then via Lemma \ref{lma:tau-transform}, we can derive the following equation:

	\[\mathscr{T}(P') = \partial_{H_{0}}\Bigl(f_{1}\Bigl[\mathscr{T}(P')\, | | \,\tau.\Gamma[\mathscr{T}(Q')]\Bigl]\Bigr)\]
		Case 2 can be repeated as many times as needed until $Q$ reaches Case 1. Via Lemma \ref{lma:tau-on-p-process}, this results in
		\[\trans{P'} = \partial_{H_{0}}(f_{1}[\trans{P'}\, | | \, \Rightarrow]) = (\trans{P'}\, | | \, \Rightarrow)\]
		Which is Branching Bisimilar via Lemma \ref{lma:tau-on-p-process}
\end{enumerate}

The first action $(a)$ can happen Strongly on the root, and any further actions are either also Strongly Bisimilar, or Branching Bisimilar. Therefore, an $a$ action on $P$ is Rooted Branching Bisimilar

% \noindent\rule{\textwidth}{0.08ex}

\textbf{Option 2}: $\tau$ action on $P$. Let $P'\in \csp$ s.t. $P \prightarrow{\tau} P'$. In the domain of $\csp$, this results in the process
\[P \square Q \prightarrow{\tau} P' \square Q\]

	Via Lemma \ref{lma:tau-transform}, we can now derive the following equation
	\[
		\partial_{H_{0}}\Bigl(f_{1}\Bigl[\Gamma[\trans{P}]\, | | \,\mathtt{choose}\, | | \,\Gamma[\trans{Q}]\Bigl]\Bigr) \prightarrow{\tau} \partial_{H_{0}}\Bigl(f_{1}\Bigl[\Gamma[\trans{P'}]\, | | \,\mathtt{choose}\, | | \,\Gamma[\trans{Q}]\Bigl]\Bigr)
			\]
Which is strongly bisimilar to $\trans{P' \square Q}$, therefore a $\tau$ action on $P$ is also Rooted Branching Bisimilar.

\noindent\rule{\textwidth}{0.08ex}

\textbf{Option 3, Option 4}: The same logic from option $1$ and option $2$ can be applied to $Q$ in reverse to obtain processes that satisfy Rooted Branching Bisimilarity.

\noindent\rule{\textwidth}{0.08ex}

We have now exhausted cases, and therefore can conclude that our translation of $\csp$ External Choice is Rooted Branching Bisimilar, and therefore a Congruence.
\end{proof}

\subsection{Stopping}

Similarly to external choice, this is also Rooted Branching Bisimilar.

A counterexample to the encoding being Strongly Bisimilar is with the trivial example
\[P = \tau,\,Q = b\]
This should yield the following process graph:
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGNpcmMiXSxbMiwwLCJcXGJ1bGxldCJdLFswLDIsIlxcYnVsbGV0Il0sWzIsMiwiXFxidWxsZXQiXSxbMCwxLCJcXHRhdSIsMix7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzAsMiwiYiIsMCx7ImNvbG91ciI6WzI0MCw2MCw2MF19LFsyNDAsNjAsNjAsMV1dLFsxLDMsImIiLDAseyJjb2xvdXIiOlsyNDAsNjAsNjBdfSxbMjQwLDYwLDYwLDFdXV0=
\[\begin{tikzcd}[cramped, column sep=scriptsize]
	\circ && \bullet \\
	\\
	\bullet && \bullet
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=1-1, to=1-3]
	\arrow["b", color={rgb,255:red,92;green,92;blue,214}, from=1-1, to=3-1]
	\arrow["b", color={rgb,255:red,92;green,92;blue,214}, from=1-3, to=3-3]
\end{tikzcd}\]

However, it yields the following

% https://q.uiver.app/#q=WzAsMTYsWzUsNCwiXFxjaXJjIl0sWzcsMywiXFxidWxsZXQiXSxbNSwzLCJcXGJ1bGxldCJdLFs3LDIsIlxcYnVsbGV0Il0sWzMsNSwiXFxidWxsZXQiXSxbMiwzLCJcXGJ1bGxldCJdLFsyLDIsIlxcYnVsbGV0Il0sWzAsNCwiXFxidWxsZXQiXSxbMyw0LCJcXGJ1bGxldCJdLFswLDMsIlxcYnVsbGV0Il0sWzksMiwiXFxidWxsZXQiXSxbOSwxLCJcXGJ1bGxldCJdLFs2LDAsIlxcYnVsbGV0Il0sWzYsMSwiXFxidWxsZXQiXSxbNCwyLCJcXGJ1bGxldCJdLFs0LDEsIlxcYnVsbGV0Il0sWzAsMSwiXFxtYXRodHR7b3JpZ2lufSIsMix7ImNvbG91ciI6WzAsMCwzOF19LFswLDAsMzgsMV1dLFswLDIsIlxcdGF1IiwyLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbMSwzLCJcXHRhdSIsMix7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzIsMywiXFxtYXRodHR7b3JpZ2lufSIsMix7ImNvbG91ciI6WzAsMCwzOF19LFswLDAsMzgsMV1dLFswLDUsImJfe1xcbWF0aHR0e2ZpcnN0fX0iLDIseyJjb2xvdXIiOlsyNDAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFsyNDAsNjAsNjAsMV1dLFsyLDYsImJfe1xcbWF0aHR0e2ZpcnN0fX0iLDIseyJjb2xvdXIiOlsyNDAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFsyNDAsNjAsNjAsMV1dLFs1LDYsIlxcdGF1IiwyLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbMCw0LCJcXG1hdGh0dHtzcGxpdH0iLDAseyJjb2xvdXIiOlswLDAsMzhdfSxbMCwwLDM4LDFdXSxbNCw3LCJiX3tcXG1hdGh0dHtmaXJzdH19IiwyLHsiY29sb3VyIjpbMjQwLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMjQwLDYwLDYwLDFdXSxbNCw4LCJcXHRhdSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzcsOSwiXFx0YXUiLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFs4LDksImJfe1xcbWF0aHR0e2ZpcnN0fX0iLDIseyJjb2xvdXIiOlsyNDAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFsyNDAsNjAsNjAsMV1dLFsyLDgsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCwzOF19LFswLDAsMzgsMV1dLFs2LDksIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCwzOF19LFswLDAsMzgsMV1dLFs1LDcsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCwzOF19LFswLDAsMzgsMV1dLFsxLDEwLCJcXG1hdGh0dHtzcGxpdH0iLDIseyJjb2xvdXIiOlswLDAsMzhdfSxbMCwwLDM4LDFdXSxbMywxMSwiXFxtYXRodHR7c3BsaXR9IiwyLHsiY29sb3VyIjpbMCwwLDM4XX0sWzAsMCwzOCwxXV0sWzExLDEyLCJiX3tcXG1hdGh0dHtmaXJzdH19IiwyLHsiY29sb3VyIjpbMjQwLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMjQwLDYwLDYwLDFdXSxbMTAsMTMsImJfe1xcbWF0aHR0e2ZpcnN0fX0iLDIseyJjb2xvdXIiOlsyNDAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFsyNDAsNjAsNjAsMV1dLFsxMCwxMSwiXFx0YXUiLDIseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxMywxMiwiXFx0YXUiLDIseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFs1LDE0LCJcXG1hdGh0dHtvcmlnaW59IiwyLHsiY29sb3VyIjpbMCwwLDM4XX0sWzAsMCwzOCwxXV0sWzYsMTUsIlxcbWF0aHR0e29yaWdpbn0iLDIseyJjb2xvdXIiOlswLDAsMzhdfSxbMCwwLDM4LDFdXSxbMSwxNCwiYl97XFxtYXRodHR7Zmlyc3R9fSIsMix7ImNvbG91ciI6WzI0MCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzI0MCw2MCw2MCwxXV0sWzMsMTUsImJfe1xcbWF0aHR0e2ZpcnN0fX0iLDIseyJjb2xvdXIiOlsyNDAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFsyNDAsNjAsNjAsMV1dLFsxNCwxNSwiXFx0YXUiLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxNSwxMiwiXFxtYXRodHR7c3BsaXR9IiwyLHsiY29sb3VyIjpbMCwwLDM4XX0sWzAsMCwzOCwxXV0sWzE0LDEzLCJcXG1hdGh0dHtzcGxpdH0iLDIseyJjb2xvdXIiOlswLDAsMzhdfSxbMCwwLDM4LDFdXSxbMCw3LCJiIiwwLHsiY29sb3VyIjpbMjQwLDYwLDYwXX0sWzI0MCw2MCw2MCwxXV0sWzIsOSwiYiIsMCx7ImNvbG91ciI6WzI0MCw2MCw2MF19LFsyNDAsNjAsNjAsMV1dLFszLDEyLCJiIiwyLHsiY29sb3VyIjpbMjQwLDYwLDYwXX0sWzI0MCw2MCw2MCwxXV0sWzEsMTMsImIiLDIseyJjb2xvdXIiOlsyNDAsNjAsNjBdfSxbMjQwLDYwLDYwLDFdXV0=
\[\begin{tikzcd}[cramped]
	&&&&&& \bullet \\
	&&&& \bullet && \bullet &&& \bullet \\
	&& \bullet && \bullet &&& \bullet && \bullet \\
	\bullet && \bullet &&& \bullet && \bullet \\
	\bullet &&& \bullet && \circ \\
	&&& \bullet
	\arrow["{\mathtt{split}}"', color={rgb,255:red,97;green,97;blue,97}, from=2-5, to=1-7]
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=2-7, to=1-7]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=2-10, to=1-7]
	\arrow["{\mathtt{origin}}"', color={rgb,255:red,97;green,97;blue,97}, from=3-3, to=2-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,97;green,97;blue,97}, from=3-3, to=4-1]
	\arrow["\tau", color={rgb,255:red,214;green,92;blue,92}, from=3-5, to=2-5]
	\arrow["{\mathtt{split}}"', color={rgb,255:red,97;green,97;blue,97}, from=3-5, to=2-7]
	\arrow["b"', color={rgb,255:red,92;green,92;blue,214}, from=3-8, to=1-7]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=3-8, to=2-5]
	\arrow["{\mathtt{split}}"', color={rgb,255:red,97;green,97;blue,97}, from=3-8, to=2-10]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=3-10, to=2-7]
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=3-10, to=2-10]
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=4-3, to=3-3]
	\arrow["{\mathtt{origin}}"', color={rgb,255:red,97;green,97;blue,97}, from=4-3, to=3-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,97;green,97;blue,97}, from=4-3, to=5-1]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=4-6, to=3-3]
	\arrow["{\mathtt{origin}}"', color={rgb,255:red,97;green,97;blue,97}, from=4-6, to=3-8]
	\arrow["b", color={rgb,255:red,92;green,92;blue,214}, from=4-6, to=4-1]
	\arrow["{\mathtt{split}}", color={rgb,255:red,97;green,97;blue,97}, from=4-6, to=5-4]
	\arrow["b"', color={rgb,255:red,92;green,92;blue,214}, from=4-8, to=2-7]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=4-8, to=3-5]
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=4-8, to=3-8]
	\arrow["{\mathtt{split}}"', color={rgb,255:red,97;green,97;blue,97}, from=4-8, to=3-10]
	\arrow["\tau", color={rgb,255:red,214;green,92;blue,92}, from=5-1, to=4-1]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=5-4, to=4-1]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=5-6, to=4-3]
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=5-6, to=4-6]
	\arrow["{\mathtt{origin}}"', color={rgb,255:red,97;green,97;blue,97}, from=5-6, to=4-8]
	\arrow["b", color={rgb,255:red,92;green,92;blue,214}, from=5-6, to=5-1]
	\arrow["{\mathtt{split}}", color={rgb,255:red,97;green,97;blue,97}, from=5-6, to=6-4]
	\arrow["{b_{\mathtt{first}}}"', color={rgb,255:red,92;green,92;blue,214}, dashed, from=6-4, to=5-1]
	\arrow["\tau", color={rgb,255:red,214;green,92;blue,92}, from=6-4, to=5-4]
\end{tikzcd}\]

Which reduces down to:
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGNpcmMiXSxbMiwwLCJcXGJ1bGxldCJdLFswLDIsIlxcYnVsbGV0Il0sWzIsMiwiXFxidWxsZXQiXSxbMCwxLCJcXHRhdSIsMix7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzIsMywiXFx0YXUiLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFswLDIsImIiLDAseyJjb2xvdXIiOlsyNDAsNjAsNjBdfSxbMjQwLDYwLDYwLDFdXSxbMSwzLCJiIiwwLHsiY29sb3VyIjpbMjQwLDYwLDYwXX0sWzI0MCw2MCw2MCwxXV1d
\[\begin{tikzcd}[cramped, column sep=scriptsize]
	\circ && \bullet \\
	\\
	\bullet && \bullet
	\arrow["\tau"', color={rgb,255:red,214;green,92;blue,92}, from=1-1, to=1-3]
	\arrow["b", color={rgb,255:red,92;green,92;blue,214}, from=1-1, to=3-1]
	\arrow["b", color={rgb,255:red,92;green,92;blue,214}, from=1-3, to=3-3]
	\arrow["\tau", color={rgb,255:red,214;green,92;blue,92}, from=3-1, to=3-3]
\end{tikzcd}\]

\subsection{Generalising}

\begin{lma}[Maybe?]{lma:maybe-prove}{}
   I claim that a Strong Bisimulation cannot occur and RBB is the finest equivalence able to be translated
\end{lma}

\begin{proof}
   Something about how taus cannot be renamed / communicated. Have not thought of it past there but it feels like it might be right as all the translations have the same issue.
\end{proof}

\chapter{Results}

\chapter{Conclusions}


\bibliographystyle{plainnat}
\bibliography{project}


\appendix

\chapter{First appendix}



\section{First section}

Any appendices, including any required ethics information, should be included
after the references.


Markers do not have to consider appendices. Make sure that your contributions
are made clear in the main body of the dissertation (within the page limit).

\end{document}
