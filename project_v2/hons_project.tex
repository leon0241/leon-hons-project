\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


\usepackage[final, nopatch=footnote]{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

\usepackage{preamble}
% \overfullrule=20mm


\begin{document}
\begin{preliminary}

\title{Honours Project}

\author{Leon Lee}
\course{Computer Science and Mathematics}
\project{4th Year Project Report}
\date{\today}

\abstract{
This skeleton demonstrates how to use the \texttt{infthesis} style for
undergraduate dissertations in the School of Informatics. It also emphasises the
page limit, and that you must not deviate from the required style.
The file \texttt{skeleton.tex} generates this document and should be used as a
starting point for your thesis. Replace this abstract text with a concise
summary of your report.
}

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
Any acknowledgements go here.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

\chapter{Background}

\section{Process Algebra}
With the growing complexities of software and systems of the world, it is key to have methods of modelling more complex systems to get a better understanding of the underlying behaviour behind processes. Efforts have been made in sequential programming as early as the 1930s with Turing Machines, and the $\lambda$-calculus. Systems in real life are rarely sequential however, and usually involve multiple processes acting simultaneously, sometimes even synchronising to interact with each other to perform tasks. These tasks that involve modelling multiple processes at once are referred to as a \textit{Concurrent System}. It is clear to see that brute forcing solutions to these problems are significantly harder than a sequential system - the processing time will grow exponentially as the number of processes increase, and modelling a system like a colony of ants is near impossible. Therefore, we will need some way to formalise these Concurrent Systems.

Concurrency has been studied in many different ways, though with the earliest  the 1960s with some notable models being Petri nets, or the Actor Model. Process Algebras are one such method of modelling a Concurrent System, where the process is modelled in such a way that it is akin to the Universal Algebras of mathematics - in which operations are defined in an axiomatic approach to create a structurally sound way of defining concurrent systems. \citep{baetenBriefHistoryProcess2005} It is easily possible to model simple systems as a flow chart or diagram as you will be able to see throughout this paper, but a formal approach like process algebras will make way for modelling more complex systems, and lays the groundwork to provide a solid foundation to prove and base claims for such systems.

A simple example in action is a process algebra where we only consider the alternative composition operator $+$, where applied to a process $a + b$ means ``Choose $a$, or choose $b$''. Process algebras can typically be modelled in a \textit{Process Graph}, which are diagrams that employ ``states'', and ``actions'' to show the traces, or paths, that a process can take. In this case, the process $a + b$ can be modelled in the following way:

% https://q.uiver.app/#q=WzAsNixbMSwxLCJcXGNpcmMiXSxbMCwyLCJcXGNpcmMiXSxbMiwyLCJcXGNpcmMiXSxbMiw1XSxbMSw1LCJcXGJ1bGxldCJdLFsxLDBdLFswLDEsImEiLDJdLFswLDIsImIiXSxbMyw0XSxbNSwwXV0=
\[\begin{tikzcd}[cramped,column sep=small]
	& {} \\
	& \circ \\
	\circ && \circ \\
	\arrow[from=1-2, to=2-2]
	\arrow["a"', from=2-2, to=3-1]
	\arrow["b", from=2-2, to=3-3]
\end{tikzcd}\]

Where the graph begins at the top into the first node, and then can either progress to the left node via the action $a$, or the right node via the action $b$. $a$ and $b$ are the actions, e.g. ``eat'' and ``drink'', while the nodes are the states, e.g. ``apple'' and ``water''

The axioms of the $+$ operator of BPA are as follows:
\begin{itemize}
    \item \textbf{Commutativity}: $a + b$
    \item \textbf{Associativity}: $(a + b) + c = a + (b + c)$
    \item \textbf{Idempotency}: $a + a = a$
\end{itemize}
Comparable to the operation axioms of a Group or Ring in Mathematics, every other operation in a process algebra is constructed similarly. In practice, most process algebras will have some form of alternative composition, but this is a very simplified example and the developed process algebras that exist are designed to handle a lot more complex situations such as unobservable actions, commonly referred to as $\tau$-actions, recursion, which lets a process repeat itself or other processes, and deadlock, which is a state where no desirable outcomes can be reached.

There are many process algebras that exist, the most famous and seminal being CSP \citep{brookesTheoryCommunicatingSequential1984}, CCS \citep{milnerCalculusCommunicatingSystems1980}, and ACP \citep{bergstraProcessAlgebraSynchronous1984}, \citep{bergstraACPtUniversalAxiom1989}, with some other popular calculi being the $\pi$-calculus and its various extensions  \citep{MILNER19921}, \citep{parrowFusionCalculusExpressiveness1998}, \citep{abadiCalculusCryptographicProtocols1999} which have been used to varying degrees in fields like Biology, Business, and Cryptography, or the Ambient Calculus \citep{cardelliMobileAmbients1998} which has been used to model mobile devices.

\section{Encodings of Process Algebra}

With the growing number of process algebras, one might begin to ask if there is a way of comparing different process algebra to each other to find the single best one, as a parallel to Turing Machines and the Church-Turing thesis. However, the wide range of applications that different process algebra are used for makes that rather impractical, and the goal of unifying all process algebra into a single theory seems further and further away as more process algebras for even more specified tasks get created.

A more reasonable approach is to compare different process algebras and their expressiveness, two main relevant methods being \textit{absolute} and \textit{relative} expressiveness.\citep{parrowExpressivenessProcessAlgebras2008} Absolute expressiveness is the idea of comparing a specific process algebra to a question and seeing if it can solve the problem - e.g. if a process algebra is Turing Complete. However, this merely biparts different algebra - the process algebra that are able to solve a specified problem, and the ones who aren't \citep{gorlaUnifiedApproachEncodability2010}. Therefore, the question of relative expressiveness - i.e. how one language compares to another is a lot more useful in terms of categorising different process algebras by expressiveness.

A well studied way of comparing expressiveness is through an ``encoding'', and whether an algebra can be translated from one to another, but not vice versa \citep{petersComparingProcessCalculi2019}. The general notion of an encoding is not defined by clear boundaries, and the criterion for a valid encoding may vary from language to language, but work has been made to try and generalise the notion of a ``valid'' encoding \citep{gorlaUnifiedApproachEncodability2010}, \citep{DBLP:conf/fossacs/Glabbeek18}.

\section{CSP}
CSP (Communicating Sequential Processes) \citep{brookesTheoryCommunicatingSequential1984} is a Process Algebra developed by Tony Hoare based on the idea of message passing via communications. It was developed in the 1980s and was one of the first of its kind, alongside CCS by Milner. CSP uses the idea of action prefixing which is where operators are of the syntax $a \to P$, where $a$ is an event and $P$ is a process. 

As taken from \citet{vanglabbeekBranchingTimeModel2017}, the syntax of CSP can be expressed as follows
\begin{align*}
   P, Q ::= &\mathrm{STOP} \mid \mathrm{div} \mid a\to P \mid P \sqcap Q \mid P \detcomp Q \mid P \triangleleft Q \mid \\
	&P | |_{A} Q \mid P \backslash A \mid f(P) \mid P \triangle Q \mid P \theta_{A} Q \mid p \mid \mu p.P
\end{align*}
where the operators are: \textit{inaction}, \textit{divergence}, \textit{action prefixing}, \textit{internal choice}, \textit{external choice}, \textit{sliding choice}, \textit{parallel composition}, \textit{concealment}, \textit{renaming}, \textit{interrupt}, and \textit{throw}.


\section{ACP}
ACP (Algebra of Communicating Processes) is a Process Algebra developed by Jan Bergstra and Jan Willem Klop \citep{bergstraProcessAlgebraSynchronous1984}. Compared to CSP, ACP is built up with an axiomatic approach in mind which does away with the idea of action prefixing and instead can allow for unguarded operations. ACP$_{\tau}$ \citep{bergstraACPtUniversalAxiom1989} is an extension of ACP that includes an extra action $\tau$ which is used to represent actions that are unobservable, or changeable, from a human perspective.

The grammar of ACP$_{\tau}$ as taken from \citep{bergstraACPtUniversalAxiom1989} is defined as such:
\begin{align*}
   P, Q ::= a \mid \delta \mid E + F \mid E . F \mid E | | F \mid E \underline{| | \,} F \mid E | F \mid \partial_{H}(E) \mid \tau_{I}
\end{align*}
where the operators are: \textit{action}, \textit{deadlock}, \textit{alternative composition}, \textit{sequential composition}, \textit{merge}, \textit{left merge}, \textit{communication merge}, \textit{encapsulation}, \textit{abstraction}

\chapter{A formal definition of CSP and ACP}

From [EXPRESSIVENESS], we represent a language $\mathscr{L}$ as a pair $(\mathbb{T}, \oper)$, where $\mathbb{T}$ is a set of valid expressions in $\mathscr{L}$, and $\oper$ is a mapping $\oper : \mathbb{T} \to \mathscr{D}$ from $\mathbb{T}$ to a set of meanings $\mathscr{D}$. We also define $A \subseteq \mathbb{T}$, where $A$ is the set of actions


Somethin something we are trying to gain an expressiveness result by translating CSP to ACP. A result of a valid translation would therefore show that CSP is \textit{at least as expressive} as ACP.

\chapter{A Translation of CSP to ACP}

As stated above, our proposed grammar of CSP consists of the operations:

\begin{align*}
   P, Q ::= &\mathrm{STOP} \mid \mathrm{div} \mid a\to P \mid P \sqcap Q \mid P \detcomp Q \mid P \triangleleft Q \mid \\
	&P | |_{A} Q \mid P \backslash A \mid f(P) \mid P \triangle Q \mid P \theta_{A} Q \mid 
\end{align*}
%\mu p.P
where the operators are: \textit{inaction}, \textit{divergence}, \textit{action prefixing}, \textit{internal choice}, \textit{external choice}, \textit{sliding choice}, \textit{parallel composition}, \textit{concealment}, \textit{renaming}, \textit{interrupt}, and \textit{throw}.

These can also be represented in the following GSOS table

[INSERT TABLE HERE]

As they are in GSOS format, these operations are compositional in CSP. For a valid translation into ACP, we will want the resulting translation to be compositional as well.

\section{Direct Translations}
Some of the basic operations of CSP have an identical equivalence in ACP, with the only difference being the syntax. These can be easily translated in the following table.

\begin{align*}
   \trans{STOP} &= \delta \\
   \trans{a \to P} &= a.\trans{P} \\
   \trans{P \backslash A} &= \partial_{A}{\trans{P}} \\
   % \trans{\mu p.P} &= \langle X \mid X = \tau.X \rangle
\end{align*}

\section{Trivial Translations}
\begin{itemize}
   \item \textbf{Divergence} is the process that diverges via infinite internal actions. It is defined by the following rule:
      \[\mathrm{div} \prightarrow{\tau} \mathrm{div}\]
      and then can be directly translated via recursion in ACP in the following rule:
      \[\trans{\mathrm{div}} = \langle X \mid X = \tau.X \rangle\] 
   \item \textbf{Renaming} is an operation that renames actions in processes according to a function. There is no equivalent function in plain $\mathrm{ACP}_{\tau}$, with the closest operation being $\tau_{I}(P)$ which abstracts actions in $I$ to internal actions.

      A proposed extension of ACP adds a Functional Renaming operator, as shown in [ON THE EXPRESSIVENESS OF ACP]. From this point forth, we will be using this extension, written as $ACP^{\tau}_{F}$. A clear translation is then shown to be
      \[\trans{f(P)} = f(\trans{P})\]
   \item \textbf{Internal Choice} is an operation that emulates a choice of actions that cannot be decided by the user. CSP in particular differs from ACP in that external choice and internal choice are separate operations, while in ACP, the alternative choice operator $+$ handles choice, albeit slightly differently. With the internal choice operator $\tau$, a translation for CSP Internal choice into ACP is easily written as
      \[\trans{P \sqcap Q} = \tau.\trans{P} + \tau.\trans{Q}\]
\end{itemize}

The above translations are all valid up to Strong Bisimilarity. The other operators are slightly harder to translate.

\section{Helper Operators for \texorpdfstring{$ACP_{F}^{\tau}$}{ACPtaur}}

Working in the language $ACP_{\tau}$ with the extension of Functional Renaming (written $ACP^{\tau}_{F}$), we start by defining some subsets of $A$ which we will use in our encodings.

\begin{dfn}[Subsets of A]{dfn:sets}{}
   The set $A\in \mathbb{T}$ is the set of all actions.
   \begin{itemize}
      \item $A_{0} \subseteq A$ is the set of actions that actually get used in processes
      \item $H_{0} = A - A_{0}$ is the set of working space operators, or any other action that doesn't get used
      \item $H_{1} = A_{0} \uplus \mathscr{H}$ is the set of actions, plus a set of working operators $\mathscr{H}$
   \end{itemize}

   In general, $A_{0} \subseteq H_{1} \subseteq A$.

   Note that the silent step is not defined in $A$, and we will define $A_{\tau}$ to be $A \cup \{\tau\}$
\end{dfn}

\newpage

\import{diagrams/}{triggering.tex}
\subsection{Triggering}
We define an operator $\Gamma(P)$ that emulates the Triggering operator of MEIJE [REFER]. For a trace $a.b.\cdots$ on a process $P$, the triggering operator can be represented as an operator that tags the first action of a process.

First, we define a function $f_{1}$ and communications for the operations $\mathtt{first}$ and $\mathtt{next}$.


\begin{multicols}{2}
   \begin{dfn-s}[Communications]{dfn:comm-triggering}{}
      Define communications where
      \begin{align*}
	 a | \mathtt{first} &= a_{\mathtt{first}}\\
	 a | \mathtt{next} &= a_{\mathtt{next}}
      \end{align*}
   \end{dfn-s}

   \begin{dfn}[F1]{dfn:f1}{}
      Define functions $f_{1}: A \to A$ where
      \begin{align*}
	 f_{1}(a_{\mathtt{first}}) &= a_{\mathtt{ini}} \\
	 f_{1}(a_{\mathtt{next}}) &= a 
      \end{align*}
   \end{dfn}
\end{multicols}

We use the notation of $a^{\infty}$ as syntactic sugar to mean $\langle X \mid X = a.X \rangle$. Using the sets defined in \ref{dfn:sets}, we can now define $\Gamma(P)$ as such:

\begin{dfn}[Triggering in ACP]{dfn:acp-triggering}{}
   \[\Gamma(P) := \rho_{f_{1}}[\partial_{H_{1}}(P | | \mathtt{first}(\mathtt{next}^{\infty}))])\]
   is an operator that turns a trace of a process $P$, $a.b.c.\dots$ into the trace
   \[a_{\mathtt{ini}}. b. c. \dots\]
\end{dfn}

This works in the following method:
\vspace{-5pt}
\begin{enumerate}[label=\alph*)]
   \item Merge the process $P$ with the process $\mathtt{first}.\mathtt{next}.\mathtt{next}\dots$. Via Def \ref{dfn:comm-triggering}, this will produce a lattice of $P$ and $\mathtt{first}.(\mathtt{next}^{\infty})$, with communications on every square, but most importantly, a chain of communications going down the centre of the form.
      \begin{equation}\label{eq:fnn}
	 a_{\mathtt{first}}. b_{\mathtt{next}} . c_{\mathtt{next}} \dots
      \end{equation}
   \item Restrict the actions in $H_{1}$. Since all the actions in $P, \mathtt{first}.(\mathtt{next}^{\infty}) \in H_{1}$ this effectively restricts both sides of the left merge, leaving only communications from the initial state. This leaves equation \ref{eq:fnn} as the only remaining trace.
   \item Apply $\rho_{f_{1}}$ to equation \ref{eq:fnn}. Via \ref{dfn:f1}, the final result is
      \begin{equation}\label{eq:gamma-result}
	 a_{\mathtt{ini}}. b . c \dots
      \end{equation}

      The process is now exactly as stated in Definition \ref{dfn:acp-triggering}.
\end{enumerate}
Note that since $\tau\not\in A$, $\partial_{H_{1}}$ will not restrict $\tau$, and additionally since $\tau$ does not communicate with any actions, Step 2 effectively becomes any amount of $\tau$ steps followed by the diagonal trace immediately following that. This results in cases $\Gamma(P)$ where $P = \tau.b.c\dots$ becoming the trace
\[\tau.b_{\mathtt{ini}}.c.\dots\]
effectively skipping $\tau$'s, then acting the same as processes that don't start with a $\tau$.


\newpage
\subsection{Poster Function}
Issues with Associativity
\begin{dfn}[Poster function]{dfn:poster}{}
   We define a compatibility function to prevent issues with associativity. Let $f_{\mathrm{post}} : A \to A$ where
   \vspace{-5pt}
   \[f_{\mathrm{post}}(a_{\mathtt{post}}) = a \quad f_{\mathrm{post}}( \alpha) = \alpha\]
\end{dfn}

\newpage
\section{Translations for the remaining CSP Operators}
\subsection{Parallel Composition}
The parallel composition $\pcomp_{A}$ is defined with the following rules:
\begin{equation}\label{eq:pcomp-definition}
   \prftree{P \prightarrow{\alpha} P' \quad \scriptstyle(\alpha\not\in A)}{P \pcomp_{A} Q \prightarrow{\alpha} P'\pcomp_{A} Q} \qquad \prftree{Q \prightarrow{\alpha} Q' \quad \scriptstyle(\alpha\not\in A) }{P \pcomp_{A} Q \prightarrow{a} P\pcomp_{A} Q'}\qquad \prftree{P \prightarrow{a} P' \, Q \prightarrow{a} Q'\scriptstyle(\alpha\in A)}{P \pcomp_{A} Q \prightarrow{a} P' \pcomp_{A} Q'}
\end{equation}
In other words, a left merge action can be taken by all actions of $P$ and $Q$, which is the same as the ACP equivalent of parallel composition with the one difference being that in CSP, the action must be the same in $P$ and $Q$, whereas in ACP the action is defined with a communication function.

For our encoding, we take $\mathscr{H} = \{\}$, and therefore $H_{1} = A_{0}$

The goal is to tag actions in the target set $A_{T}$, and then define a communication function between identical marked actions. We can do this via the following functions and communications:
\begin{multicols}{2}

\begin{dfn-s}[A-set Marking]{dfn:f-comms}{}
   We define a function $f_{A}$ to mark any actions in the target set $A_{T}$. We write $\sigma$ to indicate an action in $A_{T}$
	\[f_{2}(\sigma_{\mathtt{syn}}) = \sigma \quad f_{2}(
	\alpha) = \alpha\]
\end{dfn-s}

\begin{dfn-s}[Communication]{dfn:comm-comms}{}
   We define a communication for identical actions
   \[a_{\mathtt{syn}} | a_{\mathtt{syn}} = a_{\mathtt{post}}\]
\end{dfn-s}

\end{multicols}

A translation for Parallel Composition can then be written as the following:
\[\trans{P \pcomp Q} = \partial_{H_{0}}(\rho_{f_{\mathrm{post}}}(\rho_{f_{2}}(\trans{P}) \pcomp \rho_{f_{2}}(\trans{Q}))) \]

\subsection{External choice}


The external choice operator $\square$ is defined with the following rules:
\begin{equation}\label{eq:csp-definition}
	\prftree{P \prightarrow{a} P'}{P \square Q \prightarrow{a} P'} \qquad \prftree{Q \prightarrow{a} Q'}{P \square Q \prightarrow{a} Q'} \qquad \prftree{P \prightarrow{\tau} P'}{P \square Q \prightarrow{\tau} P' \square Q} \qquad \prftree{Q \prightarrow{\tau} Q'}{P \square Q \prightarrow{a} P \square Q'}
\end{equation}
In other words, we can take an external choice by the user, and additionally an internal action will still let an external choice be made after the internal move has been made. This differs from the ACP Alternative Choice operator ($+$), as $+$ will not let you select externally if an internal action is made.

For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{choose}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{choose}\}$ as defined in Definition \ref{dfn:sets}. We then modify Definition \ref{dfn:comm-triggering} to include an additional communication for $\mathtt{choose}$ to make

\begin{dfn-s}[Communication]{dfn:comm-ext-choice}{}
	Via $\ref{dfn:comm-triggering}$, communications are defined as:
	\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \]
	We extend the definition to include a communication for $\mathtt{choose}$
	\[a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}\]
\end{dfn-s}

Recall that the Triggering operator (\ref{dfn:acp-triggering}) is defined as:
\[\Gamma(P) := \rho_{f_{1}}[\partial_{H_{1}}(P | | \mathtt{first}(\mathtt{next}^{\infty}))])\]

We can then define an encoding of the CSP external choice operator $\square$ in ACP in the following equation
\[\mathscr{T}(P \square Q) = \partial_{H_{0}}\Bigl(\rho_{f_{2}}\Bigl[\Gamma[\mathscr{T}(P)]\, | | \,\mathtt{choose}\, | | \,\Gamma[\mathscr{T}(Q)]\Bigl]\Bigr)\]

\subsection{Stopping}

The stopping operator $\triangle$ is defined with the following rules:

\[\prftree{P \prightarrow{\alpha} P'}{P \triangle Q \prightarrow{\alpha} P' \triangle Q} \qquad \prftree{Q \prightarrow{\tau} Q'}{P \triangle Q \prightarrow{\tau} P \triangle Q'} \qquad \prftree{Q \prightarrow{a} Q'}{P \triangle Q \prightarrow{a} Q'}\]

In other words, we can take an external choice from $P$ without interrupting the operator, in addition to internal choices from $Q$. However, the moment an external choice is made from $Q$, the process will then never return to $P$.

For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{left}, \mathtt{origin}, \mathtt{split}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{left}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}. We then modify Definition \ref{dfn:comm-triggering} to include additional communications for the operators $\mathtt{left}$, $\mathtt{origin}$, and $\mathtt{split}$




\begin{dfn}[Stopping Communications]{dfn:comms-stopping}{}
   Via $\ref{dfn:comm-triggering}$, communications for the triggering operator are defined as:
   \[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \]
   We extend the definition to includes communications for the extra operators
   \[a | \mathtt{left} = a_{\mathtt{left}} \qquad a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}} \qquad a_{\mathtt{ini}} | \mathtt{split} = a_{\mathtt{post}}\]
\end{dfn}

\begin{dfn}[Functions Modified]{dfn:f2}{}
   We define a compatibility function to prevent issues with transitivity in the function to come. Let $f_{\mathtt{leftfix}} : A \to A$ where
   \[f_{\mathtt{leftfix}}(a_{\mathtt{left}}) = a_{\mathtt{origin}}\]
\end{dfn}

\begin{dfn}[Left-Tagging]{dfn:lefter}{}
	The operator $\Phi(P)$ turns a trace of a process $P$, $a.b.c$ into the trace
	\[a_{\mathtt{origin}}.b_{\mathtt{origin}}.c_{\mathtt{origin}}\]
	and is defined as
	\[\Phi(P) = \partial_{H_{1}}\left(\rho_{f_{\mathtt{leftfix}}}\left(P | | (\mathtt{left})^{\infty}\right)\right)\]
\end{dfn}


We can now define an encoding of the CSP Stopping operator $\triangle$ in $ACP_{\tau}$. We start off with a new process, which we will call $\sigma$. This is defined as the process
\[\sigma = (\mathtt{origin})^{\infty}.(\mathtt{split})^{\infty}\]
Or, visualised as a process graph:
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXGNpcmMiXSxbMiwwLCJcXGJ1bGxldCJdLFs0LDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxtYXRodHR7b3JpZ2lufSJdLFsxLDEsIlxcbWF0aHR0e29yaWdpbn0iXSxbMSwyLCJcXG1hdGh0dHtzcGxpdH0iXSxbMiwyLCJcXG1hdGh0dHtzcGxpdH0iXV0=
\[\begin{tikzcd}[]
	\circ && \bullet && \bullet
	\arrow["{\mathtt{origin}}", from=1-1, to=1-3]
	\arrow["{\mathtt{origin}}", from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow["{\mathtt{split}}", from=1-3, to=1-5]
	\arrow["{\mathtt{split}}", from=1-5, to=1-5, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\]

From this, an encoding can be written in the following way:
\[\mathscr{T}(P \triangle Q) = \partial_{H_{0}}\Bigl(\rho_{f_{\mathtt{post}}}\Bigl[
	 (\Phi(\mathscr{T}(P)) | | \sigma) | | \Gamma(\mathscr{T}(Q))
\Bigr]\Bigr)\]
\subsection{Interrupt}

The interrupt operator $\Theta_{A}$ is defined with the following rules:

\[\prftree{P \prightarrow{\alpha} P' \quad \scriptstyle(a\not\in A)}{P \Theta_{A} Q \prightarrow{\alpha} P' \Theta_{A} Q} \qquad \prftree{P \prightarrow{a} P' \quad \scriptstyle(a\in A)}{P \Theta_{A} Q \prightarrow{a} Q }\]

In other words, we can take as many actions in $P$ as we want, as long as they aren't contained in a set of actions, which we will call $A_{T}$. However, the moment an action in $A_{T}$ is made, The process then diverts to $Q$. This can be also throught as an error checking operator.

Similarly to the stopping operator, for our encoding, we take 
\[\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{left}, \mathtt{origin}, \mathtt{split}\}\]
, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{left}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}. We then modify Definition \ref{dfn:comm-triggering} to include additional communications for the operators $\mathtt{left}$, $\mathtt{origin}$, and $\mathtt{split}$

\begin{dfn}[Interrupt Communications]{dfn:comms-interrupt}{}
   Via \ref{dfn:comms-stopping}, we will follow with the same communications, i.e.
   \begin{multicols}{2}
   \begin{itemize}
      \item $a | \mathtt{first} = a_{\mathtt{first}}$
       \item $a | \mathtt{next} = a_{\mathtt{next}}$
       \item $a | \mathtt{left} = a_{\mathtt{left}}$
       \item $a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}}$
       \item $a_{\mathtt{ini}} | \mathtt{split} = a_{\mathtt{post}}$
   \end{itemize}
   \end{multicols}
\end{dfn}

We can now define an encoding of the CSP Stopping operator $\Theta_{A}$ in $ACP_{\tau}$. We employ the use of the same operator as in the Stopping operator, $\sigma$ which is defined as
\[\sigma = (\mathtt{origin})^{\infty}.(\mathtt{split})^{\infty}\]
Or, visualised as a process graph:
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXGNpcmMiXSxbMiwwLCJcXGJ1bGxldCJdLFs0LDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxtYXRodHR7b3JpZ2lufSJdLFsxLDEsIlxcbWF0aHR0e29yaWdpbn0iXSxbMSwyLCJcXG1hdGh0dHtzcGxpdH0iXSxbMiwyLCJcXG1hdGh0dHtzcGxpdH0iXV0=
\[\begin{tikzcd}[]
	\circ && \bullet && \bullet
	\arrow["{\mathtt{origin}}", from=1-1, to=1-3]
	\arrow["{\mathtt{origin}}", from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow["{\mathtt{split}}", from=1-3, to=1-5]
	\arrow["{\mathtt{split}}", from=1-5, to=1-5, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\]

From this, an encoding can be written in the following way:
\[\mathscr{T}(P \Theta_{A} Q) = \partial_{H_{0}}\Bigl(\rho_{f_{\mathtt{post}}}\Bigl[
	 \Phi(\mathscr{T}(P)) | | \sigma.\mathscr{T}(Q)
\Bigr]\Bigr)\]

% https://q.uiver.app/#q=WzAsMjUsWzAsMCwiXFxidWxsZXQiXSxbMiwwLCJcXGJ1bGxldCJdLFs0LDAsIlxcYnVsbGV0Il0sWzAsMiwiXFxidWxsZXQiXSxbMCw0LCJcXGJ1bGxldCJdLFswLDYsIlxcYnVsbGV0Il0sWzAsOCwiXFxidWxsZXQiXSxbNiwwLCJcXGJ1bGxldCJdLFs4LDAsIlxcYnVsbGV0Il0sWzIsMiwiXFxidWxsZXQiXSxbNCwyLCJcXGJ1bGxldCJdLFs2LDIsIlxcYnVsbGV0Il0sWzgsMiwiXFxidWxsZXQiXSxbMiw0LCJcXGJ1bGxldCJdLFs0LDQsIlxcYnVsbGV0Il0sWzYsNCwiXFxidWxsZXQiXSxbOCw0LCJcXGJ1bGxldCJdLFsyLDYsIlxcYnVsbGV0Il0sWzQsNiwiXFxidWxsZXQiXSxbNiw2LCJcXGJ1bGxldCJdLFs4LDYsIlxcYnVsbGV0Il0sWzIsOCwiXFxidWxsZXQiXSxbNCw4LCJcXGJ1bGxldCJdLFs2LDgsIlxcYnVsbGV0Il0sWzgsOCwiXFxidWxsZXQiXSxbMCwxLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMSwyLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMCwzLCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMyw0LCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbNCw1LCJiX3tcXG1hdGh0dHtzcGxpdH19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFs1LDYsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsyLDcsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzcsOCwicV8xIl0sWzEsOSwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzIsMTAsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFs3LDExLCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbOCwxMiwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzksMTMsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxMCwxNCwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzExLDE1LCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMTIsMTYsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxMywxNywiYl97XFxtYXRodHR7c3BsaXR9fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMTQsMTgsImJfe1xcbWF0aHR0e3NwbGl0fX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzE1LDE5LCJiX3tcXG1hdGh0dHtzcGxpdH19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxNiwyMCwiYl97XFxtYXRodHR7c3BsaXR9fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMTcsMjEsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFsxOCwyMiwiYV97XFxtYXRodHR7b3JpZ2lufX0iLDAseyJjb2xvdXIiOlswLDYwLDYwXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCw2MCw2MCwxXV0sWzE5LDIzLCJhX3tcXG1hdGh0dHtvcmlnaW59fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDYwLDYwLDFdXSxbMjAsMjQsImFfe1xcbWF0aHR0e29yaWdpbn19IiwwLHsiY29sb3VyIjpbMCw2MCw2MF0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsNjAsNjAsMV1dLFszLDksIlxcbWF0aHR0e29yaWdpbn0iLDAseyJjb2xvdXIiOlswLDAsNDNdLCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19LFswLDAsNDMsMV1dLFs5LDEwLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMTAsMTEsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzExLDEyLCJxXzEiXSxbNCwxMywiXFxtYXRodHR7b3JpZ2lufSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzEzLDE0LCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMTQsMTUsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzE1LDE2LCJxXzEiXSxbNSwxNywiXFxtYXRodHR7b3JpZ2lufSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzE3LDE4LCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMTgsMTksIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzE5LDIwLCJxXzEiXSxbNiwyMSwiXFxtYXRodHR7b3JpZ2lufSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzIxLDIyLCJcXG1hdGh0dHtvcmlnaW59IiwwLHsiY29sb3VyIjpbMCwwLDQzXSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fSxbMCwwLDQzLDFdXSxbMjIsMjMsIlxcbWF0aHR0e3NwbGl0fSIsMCx7ImNvbG91ciI6WzAsMCw0M10sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX0sWzAsMCw0MywxXV0sWzIzLDI0LCJxXzEiXSxbMCw5LCJhIl0sWzksMTQsImEiXSxbMTQsMTksImIiXSxbMywxMywiYSJdLFsxLDEwLCJhIl0sWzUsMjEsImEiXSxbMTcsMjIsImEiXV0=
\[\begin{tikzcd}[cramped, column sep=scriptsize]
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=1-1, to=1-3]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-1, to=3-1]
	\arrow["a", from=1-1, to=3-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=1-3, to=1-5]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-3, to=3-3]
	\arrow["a", from=1-3, to=3-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=1-5, to=1-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-5, to=3-5]
	\arrow["{q_1}", from=1-7, to=1-9]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-7, to=3-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=1-9, to=3-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=3-1, to=3-3]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-1, to=5-1]
	\arrow["a", from=3-1, to=5-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=3-3, to=3-5]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-3, to=5-3]
	\arrow["a", from=3-3, to=5-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=3-5, to=3-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-5, to=5-5]
	\arrow["{q_1}", from=3-7, to=3-9]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-7, to=5-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=3-9, to=5-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=5-1, to=5-3]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-1, to=7-1]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=5-3, to=5-5]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-3, to=7-3]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=5-5, to=5-7]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-5, to=7-5]
	\arrow["b", from=5-5, to=7-7]
	\arrow["{q_1}", from=5-7, to=5-9]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-7, to=7-7]
	\arrow["{b_{\mathtt{split}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=5-9, to=7-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=7-1, to=7-3]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-1, to=9-1]
	\arrow["a", from=7-1, to=9-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=7-3, to=7-5]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-3, to=9-3]
	\arrow["a", from=7-3, to=9-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=7-5, to=7-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-5, to=9-5]
	\arrow["{q_1}", from=7-7, to=7-9]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-7, to=9-7]
	\arrow["{a_{\mathtt{origin}}}", color={rgb,255:red,214;green,92;blue,92}, dashed, from=7-9, to=9-9]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=9-1, to=9-3]
	\arrow["{\mathtt{origin}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=9-3, to=9-5]
	\arrow["{\mathtt{split}}", color={rgb,255:red,110;green,110;blue,110}, dashed, from=9-5, to=9-7]
	\arrow["{q_1}", from=9-7, to=9-9]
\end{tikzcd}\]

\subsection{Sliding Choice}
The sliding choice, or timeout operator $\triangleright$ is defined with the following rules:

\[\prftree{P \prightarrow{a} P'}{P \triangleright Q \prightarrow{a} P'} \qquad \prftree{P \prightarrow{\tau} P'}{P \triangleright Q \prightarrow{\tau} P' \triangleright Q} \qquad P \triangleright Q \prightarrow{\tau} Q\]

In other words, this operator lets you take an external action on $P$, however there is a second process that may at any point before the external action taken in $P$ ``time out'' and move to $Q$ instead.

\newpage
\chapter{Validity of the Encoding}

\section{External Choice}
On a process without $\tau$, the function
\[\partial_{H_{0}}\Bigl(\rho_{f_{2}}\Bigl[\Gamma(P)\, | | \,\mathtt{choose}\, | | \,\Gamma(Q)\Bigr]\Bigr)\]
has identical behaviour to $P + Q$

On processes with internal actions, which we will call $\mathcal{P} = \tau_{P}.a.P$ and $\mathcal{Q} = \tau_{Q}.b.Q$, where $\tau_{P}$ indicates the number of starting $\tau$ actions in the process, possibly 0, the $\tau$ cannot communicate with $\mathtt{choose}$ so $\mathtt{choose}$ will only communicate with $a$ (Since only $a$ will be labelled with $\mathtt{first}$). However, the first action of $Q$ will still have the name $b_{\mathtt{first}}$ for $b\in A$. This lets the function effectively skip the $\tau$, then perform $\mathtt{choose}$ on $a.P \,| | \,b.Q$ which matches the behaviour of CSP $\square$. 

However, this translation is not strongly bisimilar. This is due to the final restriction $\partial_{H_{0}}$, which will usually restrict any stray $a_{\mathtt{first}}$ actions (and subsequent actions/processes) that try to communicate. However, since the silent step $\tau$ is not in $A$, we will get left with stray $\tau$ actions. This doesn't hold for two processes $a.P$ and $\tau.Q$, since the translation would yield the process
\[a.(\tau | | P) + \tau.(P + Q) \ne a.P + \tau.(P + Q)\]

% \begin{figure}[t!]
% 	\centering
% 	% https://q.uiver.app/#q=WzAsNyxbMCwwLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzIsMCwiXFxidWxsZXQiXSxbMCwxLCJcXGJ1bGxldCJdLFsxLDEsIlxcYnVsbGV0Il0sWzIsMSwiXFxidWxsZXQiXSxbMywxLCJcXGJ1bGxldCJdLFswLDEsImEiXSxbMSwyLCJhIl0sWzMsNCwiYSJdLFs0LDUsIlxcdGF1Il0sWzUsNiwiYSJdLFswLDMsIiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsNCwiIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNSwxLCIiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsyLDYsIiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
% 	\[\begin{tikzcd}[cramped]
% 		\bullet & \bullet & \bullet \\
% 		\bullet & \bullet & \bullet & \bullet
% 		\arrow["a", from=1-1, to=1-2]
% 		\arrow[dashed, no head, from=1-1, to=2-1]
% 		\arrow["a", from=1-2, to=1-3]
% 		\arrow[dashed, no head, from=1-2, to=2-2]
% 		\arrow[dashed, no head, from=1-3, to=2-4]
% 		\arrow["a", from=2-1, to=2-2]
% 		\arrow["\tau", from=2-2, to=2-3]
% 		\arrow[dashed, no head, from=2-3, to=1-2]
% 		\arrow["a", from=2-3, to=2-4]
% 	\end{tikzcd}\]
% 	\caption{Branching Bisimilarity}
% 	\label{branching-bisim}
% \end{figure}

\vspace{-5pt}
\begin{figure}[!ht]
	\centering
% https://q.uiver.app/#q=WzAsMTMsWzAsMCwiXFxjaXJjIl0sWzQsMCwiXFxidWxsZXQiXSxbNiwwLCJcXGJ1bGxldCJdLFswLDIsIlxcYnVsbGV0Il0sWzYsMiwiXFxidWxsZXQiXSxbNCwyLCJcXGJ1bGxldCJdLFs2LDQsIlxcYnVsbGV0Il0sWzgsMiwiXFxidWxsZXQiXSxbMiwyLCJcXGJ1bGxldCJdLFsyLDQsIlxcYnVsbGV0Il0sWzQsNCwiXFxidWxsZXQiXSxbMyw0LCJcXGJ1bGxldCJdLFs4LDQsIlxcYnVsbGV0Il0sWzAsMSwiXFx0YXUiXSxbMCwzLCJhX1xcdGV4dHtmaXJzdH0iLDIseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxLDQsIlxcdGV4dHtjaG9vc2V9IiwxLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbMSw1LCJhX1xcdGV4dHtmaXJzdH0iLDIseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFs0LDYsImFfXFx0ZXh0e2ZpcnN0fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzUsNiwiXFx0ZXh0e2Nob29zZX0iLDEseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxLDYsImEiXSxbNCw3LCJiX1xcdGV4dHtmaXJzdH0iLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFswLDgsIlxcdGV4dHtjaG9vc2V9IiwxLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbOCw5LCJhX1xcdGV4dHtmaXJzdH0iLDAseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFszLDksIlxcdGV4dHtjaG9vc2V9IiwxLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbMCw5LCJhIl0sWzIsNywiXFx0ZXh0e2Nob29zZX0iLDEseyJjb2xvdXIiOlswLDYwLDYwXX0sWzAsNjAsNjAsMV1dLFsxLDIsImJfXFx0ZXh0e2ZpcnN0fSIsMCx7ImNvbG91ciI6WzAsNjAsNjBdfSxbMCw2MCw2MCwxXV0sWzEsNywiYiJdLFs5LDExLCJcXHRhdSJdLFsxMSwxMCwiYl9cXHRleHR7Zmlyc3R9IiwwLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbNiwxMiwiYl9cXHRleHR7Zmlyc3R9IiwwLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXSxbNywxMiwiYV9cXHRleHR7Zmlyc3R9IiwwLHsiY29sb3VyIjpbMCw2MCw2MF19LFswLDYwLDYwLDFdXV0=
\[\begin{tikzcd}[cramped]
	\circ &&&& \bullet && \bullet \\
	\\
	\bullet && \bullet && \bullet && \bullet && \bullet \\
	\\
	&& \bullet & \bullet & \bullet && \bullet && \bullet
	\arrow["\tau", from=1-1, to=1-5]
	\arrow["{a_\text{first}}"', color={rgb,255:red,214;green,92;blue,92}, from=1-1, to=3-1]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=1-1, to=3-3]
	\arrow["a", from=1-1, to=5-3]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=1-5, to=1-7]
	\arrow["{a_\text{first}}"', color={rgb,255:red,214;green,92;blue,92}, from=1-5, to=3-5]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=1-5, to=3-7]
	\arrow["b", from=1-5, to=3-9]
	\arrow["a", from=1-5, to=5-7]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=1-7, to=3-9]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=3-1, to=5-3]
	\arrow["{a_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-3, to=5-3]
	\arrow["{\text{choose}}"{description}, color={rgb,255:red,214;green,92;blue,92}, from=3-5, to=5-7]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-7, to=3-9]
	\arrow["{a_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-7, to=5-7]
	\arrow["{a_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=3-9, to=5-9]
	\arrow["\tau", from=5-3, to=5-4]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=5-4, to=5-5]
	\arrow["{b_\text{first}}", color={rgb,255:red,214;green,92;blue,92}, from=5-7, to=5-9]
\end{tikzcd}\]
	\caption{Counterexample for Strong Bisimilarity with the processes $P = a$ and $Q = \tau.b$. The result of the translation is $a.\tau + \tau.(a+b) \not\leftrightarroweq a + \tau.(a+b)$. Restricted actions are marked in red.}
	\label{fig:sb-counterexample}
\end{figure}


\chapter{Conclusions}


\bibliographystyle{plainnat}
\bibliography{project}


\appendix

\chapter{First appendix}



\section{First section}

Any appendices, including any required ethics information, should be included
after the references.

Markers do not have to consider appendices. Make sure that your contributions
are made clear in the main body of the dissertation (within the page limit).

\end{document}
