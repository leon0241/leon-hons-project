\documentclass[../hons_project.tex]{subfiles}
\begin{document}


\section{Direct Translations}\label{sc:direct-translations}
Some of the basic operations of $\csp$ have an equivalent counterpart in ACP, with the only difference being the syntax. These can be easily translated in the following table.
\begin{align*}
	\trans{STOP}           & = \delta              \\
	\trans{a \to P}        & = a.\trans{P}         \\
	\trans{P \backslash A} & = \tau_{A}{\trans{P}} \\
	% \trans{\mu p.P} &= \langle X \mid X = \tau.X \rangle
\end{align*}

\section{Trivial Translations}\label{sc:trivial-translations}
\begin{itemize}
	\item \textbf{Divergence} is the process that diverges via infinite internal actions. It is defined by the following rule:
	      \[\mathrm{div} \prightarrow{\tau} \mathrm{div}\]
	      and then can be directly translated via recursion in ACP in the following rule:
	      \[\trans{\mathrm{div}} = \langle X \mid X = \tau.X \rangle\]
	\item \textbf{Renaming} is an operation that renames actions in processes according to a function. There is no equivalent function in plain $\mathrm{ACP}_{\tau}$, with the closest operation being $\tau_{I}(P)$ which abstracts actions in $I$ to internal actions. This is possible in $\acptf$, and in fact our translation is trivially
	      \[\trans{f(P)} = f(\trans{P})\]

	\item \textbf{Internal Choice} is an operation that emulates a choice of actions that cannot be decided by the user. $\csp$ in particular differs from ACP in that external choice and internal choice are separate operations, while in ACP, the alternative choice operator $+$ handles choice, albeit slightly differently. With the internal choice operator $\tau$, a translation for $\csp$ Internal choice into ACP is easily written as
	      \[\trans{P \sqcap Q} = \tau.\trans{P} + \tau.\trans{Q}\]
\end{itemize}

The above translations are all valid up to Strong Bisimilarity. The other operators are slightly harder to translate.

\section{Helper Operators for the language \texorpdfstring{$\acptf$}{ACPtf}}

\subsection{Subsets of \texorpdfstring{$\Sigma$}{Sigma}}
Working in the language $\acpt$ with the extension of Functional Renaming (written $ACP^{\tau}_{F}$), we first recall that $\acptf$ is paramaterised by a set of actions $\Sigma$ as defined in \ref{sc:acp}. Also recall that $\Sigma_{\tau}$ is defined as the set $\Sigma \cup \{\tau\}$. We then start by defining some subsets of $\Sigma$ which we will use in our encodings.

\begin{dfn}[Subsets of A]{dfn:sets}{}
	The set $\Sigma\in \mathbb{T}$ is the set of all actions.
	\begin{itemize}
		\item $\Sigma_{0} \subseteq A$ is the set of actions that actually get used in processes
		\item $A \subseteq \Sigma$ is a set of target actions. This is used in operators such as $\csp$ Parallel Composition, which only communicates over a set.
		\item $H_{0} = \Sigma - \Sigma_{0}$ is the set of working space operators, or any other action that doesn't get used
		\item $\mathscr{H} \subseteq H_{0}$ is a selectively chosen set from $H_{0}$ to aid a translation.
		\item $H_{1} = \Sigma_{0} \uplus \mathscr{H}$ is the set of actions, plus any actions of $\mathscr{H}$
	\end{itemize}

	In general, $A \subseteq \Sigma_{0} \subseteq H_{1} \subseteq \Sigma$, and $\mathscr{H} \subseteq H_{0} \subseteq \Sigma$
\end{dfn}

\import{diagrams/}{triggering.tex}
\subsection{Triggering}
We define an operator $\Gamma(P)$ that emulates the Triggering operator of MEIJE [REFER]. For a trace $a.b.\cdots$ on a process $P$, the triggering operator can be represented as an operator that tags the first action of a process.

First, we define a function $f_{\mathtt{trig}}$ and communications for the operations $\mathtt{first}$ and $\mathtt{next}$.


\begin{multicols}{2}
\begin{dfn-s}[Communications]{dfn:comm-triggering}{}
Define communications where:
\begin{align*}
	a | \mathtt{first} & = a_{\mathtt{first}} \\
	a | \mathtt{next}  & = a_{\mathtt{next}}
\end{align*}
\end{dfn-s}


% \[
%  f_{\mathrm{syn}}(a) = \begin{cases}
%   a_{\mathtt{syn}} & \text{ if } a\in A \\
%   a           & \text{otherwise}
%  \end{cases}
% \]
\begin{dfn-s}[Triggering Function]{dfn:f1}{}
Define $f_{\mathtt{trig}}: \Sigma_{\tau} \to \Sigma_{\tau}$ where:
\[
	f_{\mathtt{trig}}(\alpha) = \begin{cases}
		a_{\mathtt{ini}} & \text{if } \alpha = a_{\mathtt{first}} \\
		a                & \text{if } \alpha = a_{\mathtt{next}}  \\
		\alpha           & \text{otherwise}
	\end{cases}
\]
\end{dfn-s}
\end{multicols}

We use the notation of $a^{\infty}$ as syntactic sugar to mean $\langle X \mid X = a.X \rangle$. Using the sets defined in \ref{dfn:sets}, we can now define $\Gamma(P)$ as such:

\begin{dfn}[Triggering in ACP]{dfn:acp-triggering}{}
	\[\Gamma(P) := f_{\mathtt{trig}}\bigl[\partial_{H_{1}}(P \merge \mathtt{first}.(\mathtt{next}^{\infty}))\bigr]\]
	is an operator that turns a trace of a process $P$, $a.b.c.\dots$ into the trace
	\[a_{\mathtt{ini}}. b. c. \dots\]
\end{dfn}

This works in the following method:
\vspace{-5pt}
\begin{enumerate}[label=\alph*)]
	\item Merge the process $P$ with the process $\mathtt{first}.\mathtt{next}.\mathtt{next}\dots$. Via Def \ref{dfn:comm-triggering}, this will produce a lattice of $P$ and $\mathtt{first}.(\mathtt{next}^{\infty})$, with communications on every square, but most importantly, a chain of communications going down the centre of the form.
	      \begin{equation}\label{eq:fnn}
		      a_{\mathtt{first}}. b_{\mathtt{next}} . c_{\mathtt{next}} \dots
	      \end{equation}
	\item Restrict the actions in $H_{1}$. Since all the actions in $P, \mathtt{first}.(\mathtt{next}^{\infty}) \in H_{1}$ this effectively restricts both sides of the left merge, leaving only communications from the initial state. This leaves equation \ref{eq:fnn} as the only remaining trace.
	\item Apply $f_{\mathtt{trig}}$ to equation \ref{eq:fnn}. Via \ref{dfn:f1}, the final result is
	      \begin{equation}\label{eq:gamma-result}
		      a_{\mathtt{ini}}. b . c \dots
	      \end{equation}

	      The process is now exactly as stated in Definition \ref{dfn:acp-triggering}.
\end{enumerate}
Note that since $\tau\not\in A$, $\partial_{H_{1}}$ will not restrict $\tau$, and additionally since $\tau$ does not communicate with any actions, Step 2 effectively becomes any amount of $\tau$ steps followed by the diagonal trace immediately following that. This results in cases $\Gamma(P)$ where $P = \tau.b.c\dots$ becoming the trace
\[\tau.b_{\mathtt{ini}}.c.\dots\]
effectively skipping $\tau$'s, then acting the same as processes that don't start with a $\tau$.

\import{diagrams/}{triggering-tau.tex}

\newpage
\subsection{Associativity and Postfix Function}
From the axioms of $\acpt$ \citep{bergstraACPtUniversalAxiom1989}, we have the following axioms of associativity with the communication operator $\mid$ shown in the table below:

\begin{table}[h!]
	\centering
	\begin{tabular}{ |c| }
		\hline
		\textbf{Communication function in $\acpt$} \\
		\hline
		$a | b = b | a$                            \\
		$(a | b) | c = a | (b | c)$                \\
		$\delta | a = \delta$                      \\
		\hline
	\end{tabular}
	\caption{Axioms of $\acpt$ Communication}
	\label{table:acpt-communication}
\end{table}

Bearing the above axioms in mind, we have the potential to run into problems with this with our communications. For example, in the proposed translation for the External Choice operator $\square$ (\ref{ssec:external-choice}), a simplified version of the translation would have the following communications:
\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \qquad a_{\mathtt{first}} | \mathtt{choose} = a\]
This might work at first glance, but the Associativity axiom does not hold true in this case, such as in the following counterexample:
\begin{align*}
	a | \mathtt{first} | \mathtt{choose} & = (a | \mathtt{first}) | \mathtt{choose} = a_{\mathtt{first}} | \mathtt{choose} = a \\
	                                     & = a | (\mathtt{first} | \mathtt{choose}) = a | \delta = \delta
\end{align*}
From this example, it is clear that the proposed communications would not satisfy the axioms of $\acpt$. It is for this reason that in \ref{dfn:f1}, we have the rule
\[f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{ini}} \qquad \text{instead of} \qquad f_{\mathtt{trig}}(a_{\mathtt{first}}) = a_{\mathtt{first}}\]
A preferred communications function is as follows:
\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \qquad a_{\mathtt{ini}} | \mathtt{choose} = a\]
\begin{align*}
	a | \mathtt{first} | \mathtt{choose} & = (a | \mathtt{first}) | \mathtt{choose} = a_{\mathtt{first}} | \mathtt{choose} = \delta \\
	                                     & = a | (\mathtt{first} | \mathtt{choose}) = a | \delta = \delta
\end{align*}
It is important to note that this scenario would never actually occur in practice, since $\Gamma(P)$ takes precedence and hence $\mathtt{first} | \mathtt{choose}$ would never happen, but the communication function must work over every action regardless of whether it will get used in practice.

% \begin{lma}[Keeping Associativity in Communications]{lma:communication-leftside}{}
% 	For three actions $a,b,c\in A$, if $a | b = c$, then if $c$ does not appear on the left-hand side of any other communication, Associativity will be satisfied.
% \end{lma}
% \begin{proof}
% 	WIP. QED
% \end{proof}

We define a compatibility function to prevent issues with associativity. Define a tag $a_{\mathtt{post}}$ which will act as $c$ for all our communications, which satisfies the Lemma. Then, our final step will be to rename $a_{post}$ back to $a$ for any affected actions. This works in the following way:
% We define a compatibility function to prevent issues with associativity. Via \ref{lma:communication-leftside}, define a tag $a_{\mathtt{post}}$ which will act as $c$ for all our communications, which satisfies the Lemma. Then, our final step will be to rename $a_{post}$ back to $a$ for any affected actions. This works in the following way:
\[a \xrightarrow{\text{Rename for Communication}} a_{\mathtt{tag}} \xrightarrow{\text{Communicate with an action}} a_{\mathtt{post}} \xrightarrow{\text{Rename for final result}} a\]

\begin{dfn}[Postfix function]{dfn:postfix}{}
	Let $f_{\mathrm{post}} : \Sigma_{\tau} \to \Sigma_{\tau}$ where
	\vspace{-5pt}
	\[f_{\mathtt{post}}(\alpha) = \begin{cases}
			a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			\alpha & \text{otherwise}
		\end{cases}\]
\end{dfn}

\newpage
\section{Translations for the remaining \texorpdfstring{$\csp$}{CSP} Operators}

\subsection{Communications and Functional Renaming}

We define communications for our translation in addition to the ones previously defined for our helper functions. Also note that these functions are defined over $\Sigma_{\tau}$ for bookkeeping purposes as internal actions $\tau$ cannot get renamed and therefore stay as an internal action no matter the function. These are defined as follows:

\begin{dfn}[Helper Functions]{dfn:helper-functions}{}
	In addition to the function $\fdef{trig}$ defined in \ref{dfn:f1}, and the postfix function defined in \ref{dfn:postfix}:
	\vspace{-8pt}
	\[f_{\mathtt{trig}}(\alpha) = \begin{cases}
			a_{\mathtt{ini}} & \text{if } \alpha = a_{\mathtt{first}} \\
			a                & \text{if } \alpha = a_{\mathtt{next}}  \\
			\alpha           & \text{otherwise}
		\end{cases} \qquad f_{\mathtt{post}}(\alpha) = \begin{cases}
			a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			\alpha & \text{otherwise}
		\end{cases}\]
	We define functions for the remaining operators below. We use the notation $A_{T}$ to signify a target set, as used in \ref{ssec:parallel-composition}, \ref{ssec:throw}, and $\lambda$ to signify actions in $A$

	\begin{enumerate}
		\item $\fdef{syn} : \Sigma_{\tau} \to \Sigma_{\tau}$ is a function that renames any actions in the target set $A$. This is used in the translation of Parallel Composition (\ref{ssec:parallel-composition})
		      \vspace{-5pt}
		      \[
			      f_{\mathrm{syn}}(\alpha) = \begin{cases}
				      \alpha_{\mathtt{syn}} & \text{ if } \alpha\in A \\
				      \alpha                & \text{otherwise}
			      \end{cases}
		      \]
		\item $\fdef{origin} : \Sigma_{\tau} \to \Sigma_{\tau}$ is a function that renames actions in a process for use in operators. This is used in the translation of the Interrupt operator (\ref{ssec:interrupt})
		      \vspace{-5pt}
		      \[\fdef{origin}(\alpha) = \begin{cases}
				      a_{\mathtt{origin}} & \text{if } a\in\Sigma \\
				      \tau                & \text{otherwise}
			      \end{cases}\]
		\item $\fdef{split} : \Sigma_{\tau} \to \Sigma_{\tau}$ is a function that renames actions in a process for use in operators, and also renames actions in the target set $A$. This is used in the translation of the Throw operator (\ref{ssec:throw})
		      \[
			      f_{\mathtt{split}}(\alpha) = \begin{cases}
				      a_{\mathtt{split}}  & \text{ if } a\in A                    \\
				      a_{\mathtt{origin}} & \text{ if } a\not\in A,\, a\in \Sigma \\
				      \tau                & \mathrm{otherwise}
			      \end{cases}
		      \]
	\end{enumerate}
\end{dfn}

\newpage
\begin{dfn}[Communications]{dfn:communications}{}
	In addition to the communications for the Triggering operator defined in \ref{dfn:comm-triggering}
	\vspace{-5pt}
	\[a | \mathtt{first} = a_{\mathtt{first}} \qquad a | \mathtt{next} = a_{\mathtt{next}} \]
	\vspace{-5pt}
	we define additional communications for the functions defined above:

	\begin{enumerate}[leftmargin=*]
		\item $a_{\mathtt{syn}} | a_{\mathtt{syn}} = a_{\mathtt{post}}$. This is used in the translation of Parallel Composition (\ref{ssec:parallel-composition})
		\item $a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}$. This is used in the translation of External choice (\ref{ssec:external-choice})
		\item $a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}}$. This is used in the translation of Interrupt and Throw operator (\ref{ssec:interrupt}, \ref{ssec:throw})
		\item $a_{\mathtt{ini}} | \mathtt{split} = a_{\mathtt{post}}$. This is used in the translation of the Interrupt operator (\ref{ssec:interrupt})
		\item $a_{\mathtt{split}} | \mathtt{split} = a_{\mathtt{post}}$. This is used in the translation of the Throw operator (\ref{ssec:throw})
	\end{enumerate}
\end{dfn}



\subsection{Parallel Composition}\label{ssec:parallel-composition}
The parallel composition $\pcomp$ is defined with the following rules:
\begin{equation}\label{eq:pcomp-definition}
	\prftree{P \prightarrow{\alpha} P' \quad \scriptstyle(\alpha\not\in A)}{P \pcomp Q \prightarrow{\alpha} P'\pcomp Q} \qquad \prftree{Q \prightarrow{\alpha} Q' \quad \scriptstyle(\alpha\not\in A) }{P \pcomp Q \prightarrow{a} P\pcomp Q'}\qquad \prftree{P \prightarrow{a} P' \, Q \prightarrow{a} Q'\scriptstyle(\alpha\in A)}{P \pcomp Q \prightarrow{a} P' \pcomp Q'}
\end{equation}
In other words, a left merge action can be taken by all actions of $P$ and $Q$, which is the same as the $\acptf$ equivalent of parallel composition with the one difference being that in $\csp$, the action must be the same in $P$ and $Q$, whereas in $\acptf$ the action is defined with a communication function. For our encoding, we take $\mathscr{H} = \{\}$, and therefore $H_{1} = \Sigma_{0}$. The goal is to tag actions in the target set $A$, and then define a communication function between identical marked actions. We can do this via the following functions and communications:

\begin{dfn}[Functions and Communications - Parallel Composition]{dfn:comms-pcomp}{}
	As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined over Parallel Composition:
	\[f_{\mathtt{syn}}(\alpha) = \begin{cases}
			a_{\mathtt{syn}} & \text{ if } \alpha\in A \\
			\alpha           & \text{otherwise}
		\end{cases} \qquad f_{\mathtt{post}}(\alpha) = \begin{cases}
			a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			\alpha & \text{otherwise}
		\end{cases}\]
	\[a_{\mathtt{syn}} | a_{\mathtt{syn}} = a_{\mathtt{post}}\]
\end{dfn}


A translation for Parallel Composition can then be written as the following:
\[\trans{P \pcomp Q} = \partial_{H_{0}}(f_{\mathrm{post}}(\fdef{syn}(\trans{P}) \merge \fdef{syn}(\trans{Q}))) \]

\subsection{External choice}\label{ssec:external-choice}


The external choice operator $\square$ is defined with the following rules:
\begin{equation}\label{eq:csp-definition}
	\prftree{P \prightarrow{a} P'}{P \square Q \prightarrow{a} P'} \qquad \prftree{Q \prightarrow{a} Q'}{P \square Q \prightarrow{a} Q'} \qquad \prftree{P \prightarrow{\tau} P'}{P \square Q \prightarrow{\tau} P' \square Q} \qquad \prftree{Q \prightarrow{\tau} Q'}{P \square Q \prightarrow{a} P \square Q'}
\end{equation}
In other words, we can take an external choice by the user, and additionally an internal action will still let an external choice be made after the internal move has been made. This differs from the $\acptf$ Alternative Choice operator ($+$), as $+$ will not let you select externally if an internal action is made. For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{choose}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{choose}\}$ as defined in Definition \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - External Choice]{dfn:comms-external}{}
	As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined over External Choice:
	\[f_{\mathtt{trig}}(\alpha) = \begin{cases}
			a_{\mathtt{ini}} & \text{if } \alpha = a_{\mathtt{first}} \\
			a                & \text{if } \alpha = a_{\mathtt{next}}  \\
			\alpha           & \text{otherwise}
		\end{cases} \qquad f_{\mathtt{post}}(\alpha) = \begin{cases}
			a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			\alpha & \text{otherwise}
		\end{cases}
	\]
	\[
		a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}
	\]
	\longrule{0.08ex}

	Additionally, recall that the Triggering operator (\ref{dfn:acp-triggering}) is defined as:
	\[\Gamma(P) := f_{\mathtt{trig}}[\partial_{H_{1}}(P \merge \mathtt{first}(\mathtt{next}^{\infty}))])\]
\end{dfn}


We can then define an encoding of the $\csp$ external choice operator $\square$ in $\acptf$ in the following equation
\[\trans{P \square Q} = \partial_{H_{0}}\Bigl(f_{2}\Bigl[\Gamma[\trans{P}]\, \merge \,\mathtt{choose}\, \merge \,\Gamma[\trans{Q}]\Bigl]\Bigr)\]

\subsection{Sliding Choice}\label{ssec:sliding-choice}
The sliding choice, or sliding operator $\triangleright$ is defined with the following rules:

\[\prftree{P \prightarrow{a} P'}{P \triangleright Q \prightarrow{a} P'} \qquad \prftree{P \prightarrow{\tau} P'}{P \triangleright Q \prightarrow{\tau} P' \triangleright Q} \qquad P \triangleright Q \prightarrow{\tau} Q\]

In other words, this operator lets you take an external action on $P$, however there is a second process that may at any point``time out'' and move to $Q$ instead.

For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{shift}\}$, and therefore $H_{1} = \Sigma_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{shift}\}$ as defined in \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - Sliding Choice]{dfn:comms-sliding}{}
	As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined for our translation
	\begin{align*}
		f_{\mathtt{trig}}(\alpha)             & = \begin{cases}
			                                          a_{\mathtt{ini}} & \text{if } \alpha = a_{\mathtt{first}} \\
			                                          a                & \text{if } \alpha = a_{\mathtt{next}}  \\
			                                          \alpha           & \text{otherwise}
		                                          \end{cases} \quad
											  &f_{\mathtt{post}}(\alpha)             = \begin{cases}
			                                          a      & \text{ if } \alpha = a_{\mathtt{post}} \\
			                                          \alpha & \text{otherwise}
		                                          \end{cases}                                                                    \\
	\end{align*}
		\[a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}\]

	\longrule{0.08ex}

	Additionally, recall that the Triggering operator (\ref{dfn:acp-triggering}) is defined as:
	\[\Gamma(P) := f_{\mathtt{trig}}[\partial_{H_{1}}(P \merge \mathtt{first}(\mathtt{next}^{\infty}))])\]
\end{dfn}

We can now define an encoding of the $\csp$ Sliding choice operator $\sliding$ in $\acptf$ in the following equation:
\[\trans{P \sliding Q} = \partial_{H_{0}}\Bigl(\tau_{\{\mathtt{shift}\}}\bigl(f_{\mathtt{post}}\Bigl[ \Gamma(\trans{P}) \merge \mathrm{choose} \merge \mathtt{shift}_{\mathtt{ini}} . \trans{Q}) \Bigr]\bigr)\Bigr)\]


\subsection{Interrupt}\label{ssec:interrupt}

The Interrupt operator $\interrupt$ is defined with the following rules:

\[\prftree{P \prightarrow{\alpha} P'}{P \interrupt Q \prightarrow{\alpha} P' \interrupt Q} \qquad \prftree{Q \prightarrow{\tau} Q'}{P \interrupt Q \prightarrow{\tau} P \interrupt Q'} \qquad \prftree{Q \prightarrow{a} Q'}{P \interrupt Q \prightarrow{a} Q'}\]

In other words, we can take an external action from $P$ without fulfilling the operator, in addition to internal actions from $Q$. However, the moment an external action is made from $Q$, the process can then never return to $P$.

For our encoding, we take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - Interrupt]{dfn:comms-interrupt}{}
	As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined for our translation:q
	\begin{align*}
		f_{\mathtt{trig}}(\alpha)             & = \begin{cases}
			                                          a_{\mathtt{ini}} & \text{if } \alpha = a_{\mathtt{first}} \\
			                                          a                & \text{if } \alpha = a_{\mathtt{next}}  \\
			                                          \alpha           & \text{otherwise}
		                                          \end{cases} \quad
											  &f_{\mathtt{post}}(\alpha)             = \begin{cases}
			                                          a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			                                          \alpha & \text{otherwise}
		                                          \end{cases}                                                                    \\
		\fdef{origin}(\alpha)                 & = \begin{cases}
			                                          a_{\mathtt{origin}} & \text{if } a\in\Sigma \\
			                                          \tau                & \text{otherwise}
		                                          \end{cases}\quad
											  &\begin{split}
		    a_{\mathtt{origin}} | \mathtt{origin} &= a_{\mathtt{post}} \\ a_{\mathtt{ini}} | \mathtt{split} &= a_{\mathtt{post}}
		\end{split}
	\end{align*}

	\longrule{0.08ex}

	Additionally, recall that the Triggering operator (\ref{dfn:acp-triggering}) is defined as:
	\[\Gamma(P) := f_{\mathtt{trig}}[\partial_{H_{1}}(P \merge \mathtt{first}(\mathtt{next}^{\infty}))])\]
\end{dfn}

We can now define an encoding of the $\csp$ Interrupt operator $\interrupt$ in $\acptf$. We start off with a new hoper process, which we will call $\Pi$. This is defined as the recursive equation
\[\Pi = \langle X \mid X = \mathtt{origin}.X + \mathtt{split} \rangle\]
Or, visualised as a process graph:
% https://q.uiver.app/#q=WzAsMyxbMSwwLCJcXGNpcmMiXSxbMywwLCJcXGJ1bGxldCJdLFswLDBdLFswLDEsIlxcbWF0aHR0e3NwbGl0fSJdLFswLDAsIlxcbWF0aHR0e29yaWdpbn0iXSxbMiwwLCIiLDAseyJzaG9ydGVuIjp7InNvdXJjZSI6NTB9fV1d
\[\begin{tikzcd}[column sep=scriptsize, row sep=scriptsize]
		{} & \circ && \bullet
		\arrow[shorten <=8pt, from=1-1, to=1-2]
		\arrow["{\mathtt{origin}}", from=1-2, to=1-2, loop, in=55, out=125, distance=10mm]
		\arrow["{\mathtt{split}}", from=1-2, to=1-4]
	\end{tikzcd}\]

From this, an encoding can be written in the following way:
\[\trans{P \interrupt Q} = \partial_{H_{0}}\Bigl(f_{\mathtt{post}}\Bigl[ \bigl(f_{\mathtt{origin}}(\trans{P}) \merge \Pi\bigr) \merge \Gamma(\trans{Q}) \Bigr]\Bigr)\]
\subsection{Throw}\label{ssec:throw}

The Throw operator $\throw$ is defined with the following rules:

\[\prftree{P \prightarrow{\alpha} P' \quad \scriptstyle(a\not\in A)}{P \throw Q \prightarrow{\alpha} P' \throw Q} \qquad \prftree{P \prightarrow{a} P' \quad \scriptstyle(a\in A)}{P \throw Q \prightarrow{a} Q }\]

In other words, we can take as many actions in $P$ as we want, as long as they aren't contained in a set of actions, which we will call $A_{T}$. However, the moment an action in $A_{T}$ is made, The process then diverts to $Q$. This can be also throught as an error checking operator. Similarly to the interrupt operator, for our encoding, we take
\[\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}\]
, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}.

\begin{dfn}[Functions and Communications - Throw]{dfn:comms-throw}{}
	As defined in \ref{dfn:helper-functions} and \ref{dfn:communications}, the following communications and functions are defined for our translation:
	\[f_{\mathtt{post}}(\alpha) = \begin{cases}
			a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			\alpha & \text{otherwise}
		\end{cases} \qquad f_{\mathtt{split}}(\alpha) = \begin{cases}
				      a_{\mathtt{split}}  & \text{ if } a\in A                    \\
				      a_{\mathtt{origin}} & \text{ if } a\not\in A,\, a\in \Sigma \\
				      \tau                & \mathrm{otherwise}
			      \end{cases}\]
	\[a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}} \qquad a_{\mathtt{split}} | \mathtt{split} = a_{\mathtt{post}}\]
\end{dfn}

We can now define an encoding of the $\csp$ Throw operator $\throw$ in $\acptf$. We employ the use of the same helper process as in the translation of the Interrupt operator, $\Pi$ which is defined as
\[\Pi = \langle X \mid X = \mathtt{origin}.X + \mathtt{split} \rangle\]
Or, visualised as a process graph:
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXGNpcmMiXSxbMiwwLCJcXGJ1bGxldCJdLFs0LDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxtYXRodHR7b3JpZ2lufSJdLFsxLDEsIlxcbWF0aHR0e29yaWdpbn0iXSxbMSwyLCJcXG1hdGh0dHtzcGxpdH0iXSxbMiwyLCJcXG1hdGh0dHtzcGxpdH0iXV0=
\[\begin{tikzcd}[column sep=scriptsize, row sep=scriptsize]
		{} & \circ && \bullet
		\arrow[shorten <=8pt, from=1-1, to=1-2]
		\arrow["{\mathtt{origin}}", from=1-2, to=1-2, loop, in=55, out=125, distance=10mm]
		\arrow["{\mathtt{split}}", from=1-2, to=1-4]
	\end{tikzcd}\]

From this, an encoding can be written in the following way:
\[\trans{P \throw Q} = \partial_{H_{0}}\Bigl(f_{\mathtt{post}}\Bigl[ f_{\mathtt{split}}(\trans{P}) | | \Pi.\trans{Q} \Bigr]\Bigr)\]





\newpage
\subsection{Final Translation}

Recall the grammar of the languages $\csp$ and $\acptf$ as defined in Definitions
\begin{align*}
	P, Q ::= & \mathrm{STOP} \mid \mathrm{div} \mid a\to P \mid P \sqcap Q \mid P \extchoice Q \mid P \sliding Q \mid \\
			 &P | |_{A} Q \mid P \backslash A \mid f(P) \mid P \triangle Q \mid P \theta_{A} Q \mid
\end{align*}

\vspace{-10pt}
Recall from Definitions \ref{dfn:helper-functions} and \ref{dfn:communications} the list of helper functions and communications:

\begin{multicols}{2}
	\begin{itemize}[leftmargin=*]
		\item $f_{\mathtt{trig}}(\alpha) = \begin{cases}
			a_{\mathtt{ini}} & \text{if } \alpha = a_{\mathtt{first}} \\
			a                & \text{if } \alpha = a_{\mathtt{next}}  \\
			\alpha           & \text{otherwise}
		\end{cases}$
		
		\item $f_{\mathtt{post}}(\alpha) = \begin{cases}
			a      & \text{ if } \alpha = a_{\mathrm{post}} \\
			\alpha & \text{otherwise}
		\end{cases}$
		
		\item $f_{\mathrm{syn}}(\alpha) = \begin{cases}
				      \alpha_{\mathtt{syn}} & \text{ if } \alpha\in A \\
				      \alpha                & \text{otherwise}
			      \end{cases}$
				  
		\item $\fdef{origin}(\alpha) = \begin{cases}
				      a_{\mathtt{origin}} & \text{if } a\in\Sigma \\
				      \tau                & \text{otherwise}
			      \end{cases}$
		\item $f_{\mathtt{split}}(\alpha) = \begin{cases}
				      a_{\mathtt{split}}  & \text{ if } a\in A                    \\
				      a_{\mathtt{origin}} & \text{ if } a\not\in A,\, a\in \Sigma \\
				      \tau                & \mathrm{otherwise}
			      \end{cases}$
	\end{itemize}
\end{multicols}

\begin{multicols}{3}
	\begin{itemize}[leftmargin=*]
		\item $a | \mathtt{first} = a_{\mathtt{first}}$
		\item $a | \mathtt{next} = a_{\mathtt{next}} $
		\item $a_{\mathtt{syn}} | a_{\mathtt{syn}} = a_{\mathtt{post}}$
		\item $a_{\mathtt{ini}} | \mathtt{choose} = a_{\mathtt{post}}$
		\item $a_{\mathtt{origin}} | \mathtt{origin} = a_{\mathtt{post}}$
		\item $a_{\mathtt{ini}} | \mathtt{split} = a_{\mathtt{post}}$
		\item $a_{\mathtt{split}} | \mathtt{split} = a_{\mathtt{post}}$
	\end{itemize}
\end{multicols}


We take $\mathscr{H} = \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}, \mathtt{shift}, \mathtt{choose}\}$, and therefore $H_{1} = A_{0} \uplus \{\mathtt{first}, \mathtt{next}, \mathtt{origin}, \mathtt{split}\}$ as defined in \ref{dfn:sets}. We now define our translation:

\newpage
\begin{dfn}[Translation of CSP to ACP]{dfn:trans}{}
	Let $\tcsp$ be the expressions in the language $\csp$, and $\tacp$ be expressions in the language $\acptf$. We define a translation $\tran : \tcsp \to \tacp$ defined as such:
	\begin{align*}
		\trans{STOP}           & = \delta                                                                                                                        \\
		\trans{\mathrm{div}}   & = \langle X \mid X = \tau.X \rangle                                                                                             \\
		\trans{a \to P}        & = a.\trans{P}                                                                                                                   \\
		\trans{P \intchoice Q} & = \tau.\trans{P} + \tau.\trans{Q}                                                                                               \\
		\trans{P \extchoice Q} & = \partial_{H_{0}}\Bigl(\fdef{post}\Bigl[\Gamma[\trans{P}]\, \merge \,\mathtt{choose}\, \merge \,\Gamma[\trans{Q}]\Bigl]\Bigr)  \\
			\trans{P \sliding Q} &= \partial_{H_{0}}\Bigl(\tau_{\{\mathtt{shift}\}}\bigl(f_{\mathtt{post}}\Bigl[ \Gamma(\trans{P}) \merge \mathrm{choose} \merge \mathtt{shift}_{\mathtt{ini}} . \trans{Q}) \Bigr]\bigr)\Bigr) \\
		\trans{P \pcomp Q}     & = \partial_{H_{0}}\Bigl(\fdef{post}\Bigl[\fdef{syn}(\trans{P}) \merge \fdef{syn}(\trans{Q})\Bigr]\Bigr)                         \\
		\trans{P \backslash A} & = \partial_{A}{\trans{P}}                                                                                                       \\
		% \trans{\mu p.P} &= \langle X \mid X = \tau.X \rangle
		\trans{f(P)}           & = f(\trans{P})                                                                                                                  \\
		\trans{P \interrupt Q}  & = \partial_{H_{0}}\Bigl(\fdef{post}\Bigl[ \bigl((\fdef{origin}\trans{P}) \merge \Pi\bigr) \merge \Gamma(\trans{Q}) \Bigr]\Bigr) \\
		\trans{P \throw Q} & = \partial_{H_{0}}\Bigl(\fdef{post} \Bigl[ (\fdef{split} \trans{P}) | | \Pi.\trans{Q} \Bigr]\Bigr)
	\end{align*}
\end{dfn}
\end{document}
