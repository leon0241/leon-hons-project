\documentclass[../hons_project.tex]{subfiles}
\begin{document}
    
\section{Languages and Expressiveness}\label{ssec:language}

We first define formally what it means to be a language.
\begin{dfn}[Languages]{dfn:languages}{}
   Via \cite{DBLP:conf/fossacs/Glabbeek18}, we can represent a language $\mathscr{L}$ as a pair $(\mathbb{T}, \oper)$, where $\mathbb{T}$ is a set of valid expressions in $\mathscr{L}$, and $\oper$ is a mapping $\oper : \mathbb{T} \to \mathscr{D}$ from $\mathbb{T}$ to a set of meanings $\mathscr{D}$.
\end{dfn}

The expressiveness of two languages, $\mathscr{L}$ and $\mathscr{L}'$ can be measured using a Translation, i.e. a way to map expressions in one language to another
\begin{dfn}[Translation]{dfn:translation}{}
   Via  \cite{DBLP:conf/fossacs/Glabbeek18}, a \textbf{translation} from a language $\mathscr{L}$ to a language $\mathscr{L'}$ is a mapping $\tran : \expres_{\mathscr{L}} \to \expres_{\mathscr{L}'}$
\end{dfn}



The preferred way to measure expressiveness is via relative expressiveness, compared to Absolute expressiveness. Via \cite{parrowExpressivenessProcessAlgebras2008}, absolute expressiveness measures the way that processes compare against each other, i.e. if a process in an algebra can be represented by another. Relative expressiveness takes a more robust approach, in trying to encode the individual operations of the algebra compared to entire processes. From the encoding of operators, entire processes can then be constructed, therefore satisfying Absolute Expressiveness as well.

\begin{dfn}[Expressiveness]{dfn:expressiveness}{}
   Via  \cite{DBLP:conf/fossacs/Glabbeek18}, a language $\mathscr{L}'$ is \textbf{at least as expressive as $\mathscr{L}$} iff a \textbf{valid} translation from $\mathscr{L}$ into $\mathscr{L}'$ exists.
\end{dfn}

The wording of ``valid'' is intentionally left vague, as there are many notions of validity. Validity is measured using a relation, and the strongest relation there is between two Algebas is a Bisimulation. This is a relation where any behaviour in an algebra can be identically replicated by another, therefore perfectly simulating each other. As we will see, while bisimulation is ideal, it is not always possible to achieve. Listed in \cite{parrowExpressivenessProcessAlgebras2008} is also a range of weaker criterons that are desirable for a translation. One particular criteron that we will focus on is \textbf{compositionality}, which, when achieved, means that the translations of an operator is valid regardless of the context inside them, which means that any expression will be encodable from one algebra to another by translating smaller and smaller segments of the expression.

\begin{dfn}[Compositionality]{dfn:compositionality}{}
   Via \cite{DBLP:conf/fossacs/Glabbeek18}, a translation $\mathscr{T}$ from $\mathscr{L}$ into a language $\mathscr{L}'$ is \textbf{compositional} if $\trans{X} = X$ for each $X\in \mathscr{X}$, and for each $n$-ary operator $f$ of $\mathscr{L}$ there exists an $n$'ary $\mathscr{L}$-context $C_{f}$ such that $\trans{f(E_{1},\dots,E_{n})} = C_{f}[\trans{E_{1},\dots,\trans{E_{n}}}]$ for any $\mathscr{L}$ expressions $E_{1},\dots,E_{n}\in \mathbb{T}_{\mathscr{L}}$
\end{dfn}

Here, the set $\mathscr{X}$ is the set of process variables, such as specified in the recursive specification. We should also specify that $\trans{a} = a$ for each $a\in A$ specifies that any actions are consistent between algebras.

\section{\texorpdfstring{$\acptf$}{ACP-tf}}\label{sc:acp}

\subsection{Basic \texorpdfstring{$\acpt$}{acpt}}
\begin{dfn}[\texorpdfstring{$\acpt$}{acpt}]{dfn:acpt}{}
   The base process algebra $\acpt$ as described in \cite{bergstraACPtUniversalAxiom1989} is parameterised by a set of actions, $\Sigma$, and a communication function $|$. The grammar of $\acpt$ can be described with the following operations:
   \begin{align*}
      P, Q ::= a \mid \delta \mid E . F \mid E + F \mid E \merge F \mid E \leftmerge F \mid E | F \mid \restrict(E) \mid \tau_{I}(P) \mid
   \end{align*}
   where the operators are: \textit{action}, \textit{deadlock}, \textit{sequential composition}, \textit{alternative composition},  \textit{merge}, \textit{left merge}, \textit{communication merge}, \textit{encapsulation}, and \textit{abstraction}.
\end{dfn}
We have that $H, I \subseteq \Sigma$, and additionally we will define the set $\Sigma_{\tau}$ to be the set $\Sigma \cup \{\tau\}$, as the silent step is not included in $\Sigma$. The operations can be described in the following manner:



\begin{itemize}
   \item \textbf{Action}, or $a$, is any action.
   \item \textbf{Deadlock}, or $\delta$, is the empty process. This is not marked as terminating, and so can also be thought of as an ``unfinished'' process
   \item \textbf{Sequential Composition}, or $P . Q$ is an operation that performs $P$, and then performs $Q$.
   \item \textbf{Parallel Composition}, or $P + Q$ is a process that can perform $P$ or $Q$. 
   \item \textbf{Restriction}, or $\partial_{H}(P)$, is a process with all actions in $H$ removed.
   \item \textbf{Abstraction}, or $\tau_{I}(P)$, is a process with all actions in $I$ renamed to internal actions, or $\tau$.
\end{itemize}

\subsection{Communication and Merge}\label{ssec:acp-communication}
The operations Merge ($P \merge Q$), Left Merge ($P \leftmerge Q$), and Communication Merge ($P \mid Q$) form the basis of Communication in $\acp$. Compared to the other operators of $\acp$ which symbolise actions \textit{$a$ or $b$}, and \textit{$a$ then $b$}, communication represents an action \textit{$a$ and $b$}, or in other words, a process that performs $a$ and $b$ simultaneously. The merge operation is characterised as 
\[P \merge Q = P \leftmerge Q + Q \leftmerge P + P \mid Q\]
and along with a simplified axiom set of the Left Merge operator found in $\acp$ [CITE], 
\[a \leftmerge Q = a.Q \qquad a.P \leftmerge Q = a(P \merge Q)\]
The result of $P \merge Q$ is a lattice of any combination of moves of $P$, as well as any combination of moves of $Q$, while at each step also performing $P \mid Q$. 

The operation $\mid$ is a function $A \times A \rightharpoonup A$ that defines valid communications between the two processes\footnote{Communication Merge is a Partial Function, meaning it is not defined over all actions}. This can be thought of as a hand-shaking action between $P$ and $Q$. Together with the restriction operator, communications can now be formed between two processes. An example is shown in Figure \ref{fig:communication}.

\import{diagrams/}{communication}

\subsection{\texorpdfstring{$\acptf$}{acptf}}
A proposed extension of ACP adds a Functional Renaming operator, as shown in \cite{vanglabbeekExpressivenessACP1995}, which lets you rename actions via a function $f : A \times A \rightharpoonup A$. From this point forth, we will be using this extension, written as $ACP^{\tau}_{F}$. Our final grammar for the language $\acptf$ is formally defined below.

\begin{dfn}[\texorpdfstring{$\acptf$}{acptf}]{dfn:acptf}{}
   The Algebra $\acptf$ as described in \cite{bergstraACPtUniversalAxiom1989}, \cite{vanglabbeekExpressivenessACP1995}, is parameterised by a set of actions, $\Sigma$, and a communication function $|$. The grammar of $\acptf$ can be described with the following operations:
\begin{align*}
   P, Q ::= a \mid \delta \mid P . Q \mid P + Q \mid P \merge Q \mid P \leftmerge Q \mid P | Q \mid \restrict(P) \mid \abtau(P) \mid f(P) \mid
\end{align*}
where the operators are: \textit{action}, \textit{deadlock}, \textit{sequential composition}, \textit{alternative composition},  \textit{merge}, \textit{left merge}, \textit{communication merge}, \textit{encapsulation}, \textit{abstraction}, \textit{functional renaming}.
\end{dfn}


\section{\texorpdfstring{$\csp$}{CSP}}\label{ssec:CSP}
\begin{dfn}[\texorpdfstring{$CSP$}{csp}]{dfn:csp}{}

   The process algebra $\csp$ as defined in [REF] is parameterised on a set of communications $\Sigma$, and the grammar consists of the operations:
   \begin{align*}
      P, Q ::= &\mathrm{STOP} \mid \mathrm{div} \mid a\to P \mid P \sqcap Q \mid P \extchoice Q \mid P \sliding Q \mid \\
	       &P \pcomp Q \mid P \backslash A \mid f(P) \mid P \stopping Q \mid P \interrupt Q \mid 
   \end{align*}
%\mu p.P
   where the operators are: \textit{inaction}, \textit{divergence}, \textit{action prefixing}, \textit{internal choice}, \textit{external choice}, \textit{sliding choice}, \textit{parallel composition}, \textit{concealment}, \textit{renaming}, \textit{interrupt}, and \textit{throw}.
\end{dfn}
We have that $A \subseteq \Sigma$, and the operations can be described in the following manner:


% TODO: If we translate CSP as given into ACP, there is no successful termination in CSP. Hence one could perhaps use a form of branching bis. without clauses for termination. 

\begin{itemize}
    \item \textbf{Inaction}, or $\mathrm{STOP}$, is the process that does nothing.
    \item \textbf{Divergence}, or $\mathrm{div}$, is a process that is stuck in an infinite processing loop, and can never perform an external action. As explained in section \ref{sc:trivial-translations}, this can be thought as an infinite chain of internal actions.
    \item \textbf{Action Prefixing}, or $a \to P$, is an operation that performs the action $a$ followed by the process $P$. Note that $a$ must be a \textit{single} action, therefore disallowing operations such as the process $(a \to b) \to (c \to d)$.
    \item \textbf{Internal Choice}, or $P \intchoice Q$, is an operation that can perform either $P$ or $Q$, but the choice is not decided by the user but rather by an outside decision, similar to flipping a coin
    \item \textbf{External Choice}, or $P \extchoice Q$, is an operation that can perform a choice of $P$ or $Q$, and the choice is decided by the user. Internal choices can still progress on each process and the External choice does not disappear. This differs from $\acp$ Alternative Composition, as in $\acp$ a $\tau$ action will satisfy the $+$ operation.
    \item \textbf{Sliding Choice}, or $P \sliding Q$, is an operation that acts like \textit{external choice} on $P$, and \textit{internal choice} on $Q$.
    \item \textbf{Parallel Composition}, or $P \pcomp Q$ is an operation that interleaves two processes together, similarly to $\acp$ Merge. The difference being that in the language of $\csp$, the only actions that can synchronise are identical actions, e.g. $a$ and $a$ compared to the synchronisable actions being defined with an operator like $\mid$.
    \item \textbf{Concealment}, or $P \conceal Q$, is an operation that removes actions from a set $Q$, acting similarly to the Abstraction operator $\abtau$ of $\acp$.j
    \item \textbf{Renaming}, or $f(P)$, is an operation that renames actions in accordance to a function $f : A \times A \rightharpoonup A$.
    \item \textbf{Interrupt}, or $P \stopping Q$, is an operation that can perform visible actions of $P$, but the moment an action in $Q$ is made, it will then turn into $Q$ and stop other actions of $P$ from happening.j
    \item \textbf{Throw}, or $P \interrupt Q$, is an operation that has a set of ``throw'' actions, where the process can perform visible actions of $P$, but the moment an action in the ``throw'' set occurs, the process switches to $Q$. This can also be thought of as an error operator.
\end{itemize}

\section{Structured Operational Semantics}
Structured Operational Semantics [REF] are a method of describing the actions of a process. They are laid out in Proof tables, in the form:
\[\prftree{\text{\textbf{Statement A}}}{\text{\textbf{Statement B}}} \qquad \prftree{}{\text{\textbf{Statement C}}}\]
A double sided tree means that \textbf{Statement A} implies \textbf{Statement B}, or can be read as ``If \textbf{Statement A} is true, then so is \textbf{Statement B}''. Proof tables can also be in the form of an Axiom, as shown in \textbf{Statement C}. This can be read as ``if True is true, then so is \textbf{Statement C}'', which is clearly valid.\footnote{We will express axioms without the Proof Table line for clarity}

To show an example of an operation in the GSOS Format, we will show the rules of $\acp$ Merge as explained in Section \ref{ssec:acp-communication}:
\[
\displaystyle\frac{P\prightarrow{\alpha} P'}{P \merge Q \prightarrow{\alpha} P' \merge Q} \qquad 
\displaystyle\frac{P\prightarrow{a} P'~~Q\prightarrow{b} Q'~~ a \mid b = c}{P \merge Q \prightarrow{a} P' \merge Q'} \qquad 
\displaystyle\frac{Q\prightarrow{\alpha} Q'}{P \merge Q \prightarrow{\alpha} P \merge Q'}
\]
where the meaning of the proof tables is:
\begin{itemize}
    \item If $P$ can perform an action $\alpha$ to $P'$, then $P \merge Q$ can perform an action $\alpha$ to $P' \merge Q$
    \item If $P$ can perform an action $a$ to $P'$, and $Q$ can perform an action $b$ to $Q'$ such that $a | b = c$ is defined on the Communication Merge, then $P \merge Q$ can perform an action $c$ to $P' \merge Q'$
    \item If $Q$ can perform an action $\alpha$ to $Q'$, then $P \merge Q$ can perform an action $\alpha$ to $P \merge Q'$
\end{itemize}

The rest of the operations of $\acptf$ and $\csp$ can also be represented similarly in the following GSOS tables:

\import{tables/}{gsos-csp.tex}
\import{tables/}{gsos-acp.tex}

\section{Semantic Equivalences}
Two notions of equivalence that we will be focusing on is Strong Bisimilarity, and Rooted Branching Bisimulation. As said before, Strong Bisimilarity is the finest equivalence one can have between translations. We define formally the definition of Strong Bisimulation via \cite{baetenProcessAlgebra1990}:

\begin{dfn}[Strong Bisimulation]{dfn:strong-bisim}{}
   Let $P$ and $Q$ be two processes, and $R$ be a relation between nodes of $P$ and nodes of $Q$. $R$ is a \textbf{Strong Bisimulation} between $P$ and $Q$ if:
   \begin{enumerate}
      \item The roots of $P$ and $Q$ are related by $R$
      \item If $s \prightarrow{\alpha} s'$ for $\alpha\in A_{\tau}$ is an edge in $P$, and $s R t$, then there is an edge $t \prightarrow{\alpha} t'$ such that $s' R t'$.
      \item If $t \prightarrow{\alpha} t'$ for $a\in A_{\tau}$ is an edge in $P$, and $s R t$, then there is an edge $s \prightarrow{\alpha} s'$ such that $s' R t'$.
   \end{enumerate}
\end{dfn}

To show the difference between different notions of equivalence, we will compare \textit{Bisimulation Semantics} to \textit{Trace Semantics}. \textbf{Trace Semantics} looks at different \textit{Traces}, or \textit{Paths} that a process can take. For example, in a process $P$, where $P$ is defined in the language $\acptf$ as $a . (b + c)$, we can look at \textit{Completed Trace Equivalence}. This is an equivalence that says that two processes are equivalent if they have the same set of Completed Traces\footnote{Here, \textbf{Completed Trace} refers to a path the process can take from start to end}. The traces of $P$ are therefore defined as the set
\[\{a . b,\,a . c\}\]
In Trace Semantics, the process $P$ is equivalent to the process $Q := a . b + a . c$, since they both have the traces $\{a . b,\,a . c\}$. However, this is clearly not the case in Bisimulation Semantics, where rule $2$ in Definition \ref{dfn:strong-bisim} is not satisfied, as there is no state in $Q$ that can perform both $b$ action, and a $c$ action. Clearly, this implies that \textit{Bisimulation Equivalence} is a \textbf{finer} relation than \textit{Completed Trace Equivalence}. Here, \textit{finer} means that one equivalence can distinguish between more processes than another. We will also use \textbf{coarser} to mean the opposite.

Moving on from Trace Semantics, we will look at Branching Bisimilarity, a relation where processes are deemed equivalent if they can move the same way when looking at \textbf{External actions}. In particular, this excludes internal actions, $\tau$, by saying that two processes are equivalent if two states are related, even when there are some number of internal actions between them. A finer relation than Branching Bisimilarity is Rooted Branching Bisimilarity, which adds the condition that the first action in the process must be Strongly Bisimilar, which leads to Rooted Branching Bisimilarity being a Congruence \citep{fokkinkRootedBranchingBisimulation2000}. This means that Rooted Branching Bisimilarity is not only finer than Branching Bisimilarity, but also a more robust relation, since regular Branching Bisimilarity isn't Compositional on operations such as $\acp$ $+$. We define formally the definition of Branching Bisimulation and Rooted Branching Bisimulation via \cite{baetenProcessAlgebra1990}:

\begin{dfn}[Rooted Branching Bisimilarity]{dfn:rooted-branching}{}
   Let $P$ and $Q$ be two processes, and $R$ be a relation between nodes of $P$ and nodes of $Q$. $R$ is a \textbf{Branching Bisimulation} between $P$ and $Q$ if:
   \begin{enumerate}
      \item The roots of $P$ and $Q$ are related by $R$
      \item If $s \prightarrow{a} s'$ for $a\in A \cup \{\tau\}$ is an edge in $P$, and $s R t$, then either
	 \begin{enumerate}[label=\alph*)]
	    \item $a= \tau$ and $s' R t$
	    \item $\exists t \Rightarrow t_{1} \prightarrow{a} t'$ such that $s R t_{1}$ and $s R t'$
	 \end{enumerate}
      \item If $t \prightarrow{a} t'$ for $a\in A \cup \{\tau\}$ is an edge in $Q$, and $s R t$, then either
	 \begin{enumerate}[label=\alph*)]
	    \item $a= \tau$ and $s R t'$
	    \item $\exists s \Rightarrow s_{1} \prightarrow{a} s'$ such that $s_{1} R t$ and $s' R t$
	 \end{enumerate}
   \end{enumerate}

   \longrule{0.08ex}

   $R$ is called a \textbf{Rooted Branching Bisimulation} if the following root condition is also satisfied:
   \begin{itemize}
      \item If $\mathrm{root}(P) \prightarrow{a} s'$ for $a\in A \cup \{\tau\}$, then there is a $t'$ with $\mathrm{root}(Q)\prightarrow{a} t'$ and $s' R t'$
      \item If $\mathrm{root}(Q) \prightarrow{a} t'$ for $a\in A \cup \{\tau\}$, then there is a $s'$ with $\mathrm{root}(P)\prightarrow{a} s'$ and $s' R t'$
   \end{itemize}
\end{dfn}



\end{document}
